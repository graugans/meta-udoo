From 2bd485d193c77b626f2fb4e2dff32c279bd336f3 Mon Sep 17 00:00:00 2001
From: Christian Ege <k4230r6@gmail.com>
Date: Fri, 30 Dec 2016 08:20:10 +0100
Subject: [PATCH 2/3] Added UDOO Neo support

This is a rebased version of the original patch from Francesco Montefoschi

Signed-off-by: Francesco Montefoschi <francesco.monte@gmail.com>
Signed-off-by: Christian Ege <k4230r6@gmail.com>
---
 arch/arm/cpu/armv7/mx6/Kconfig   |    5 +
 board/udoo/common/Makefile       |    7 +
 board/udoo/common/trim.c         |   34 ++
 board/udoo/common/trim.h         |   10 +
 board/udoo/neo/Kconfig           |   12 +
 board/udoo/neo/MAINTAINERS       |    6 +
 board/udoo/neo/Makefile          |    7 +
 board/udoo/neo/detectboard.c     |   62 +++
 board/udoo/neo/detectboard.h     |   14 +
 board/udoo/neo/neo.c             | 1117 ++++++++++++++++++++++++++++++++++++++
 board/udoo/neo/spl.c             |  175 ++++++
 board/udoo/quad_dual/Makefile    |    3 +-
 board/udoo/quad_dual/udoo.c      |   43 +-
 configs/udoo_neo_defconfig       |   33 ++
 include/configs/udoo_neo.h       |  213 ++++++++
 include/configs/udoo_quad_dual.h |    2 +-
 16 files changed, 1712 insertions(+), 31 deletions(-)
 create mode 100644 board/udoo/common/Makefile
 create mode 100644 board/udoo/common/trim.c
 create mode 100644 board/udoo/common/trim.h
 create mode 100644 board/udoo/neo/Kconfig
 create mode 100644 board/udoo/neo/MAINTAINERS
 create mode 100644 board/udoo/neo/Makefile
 create mode 100644 board/udoo/neo/detectboard.c
 create mode 100644 board/udoo/neo/detectboard.h
 create mode 100644 board/udoo/neo/neo.c
 create mode 100644 board/udoo/neo/spl.c
 create mode 100644 configs/udoo_neo_defconfig
 create mode 100644 include/configs/udoo_neo.h

diff --git a/arch/arm/cpu/armv7/mx6/Kconfig b/arch/arm/cpu/armv7/mx6/Kconfig
index c7581dd..2e70239 100644
--- a/arch/arm/cpu/armv7/mx6/Kconfig
+++ b/arch/arm/cpu/armv7/mx6/Kconfig
@@ -192,6 +192,10 @@ config TARGET_UDOO_QUAD_DUAL
 	bool "UDOO Quad/Dual"
 	select SUPPORT_SPL
 
+config TARGET_UDOO_NEO
+	bool "UDOO Neo"
+	select SUPPORT_SPL
+
 config TARGET_WANDBOARD
 	bool "wandboard"
 	select SUPPORT_SPL
@@ -253,6 +257,7 @@ source "board/technexion/pico-imx6ul/Kconfig"
 source "board/tbs/tbs2910/Kconfig"
 source "board/tqc/tqma6/Kconfig"
 source "board/udoo/quad_dual/Kconfig"
+source "board/udoo/neo/Kconfig"
 source "board/wandboard/Kconfig"
 source "board/warp/Kconfig"
 
diff --git a/board/udoo/common/Makefile b/board/udoo/common/Makefile
new file mode 100644
index 0000000..0729cb8
--- /dev/null
+++ b/board/udoo/common/Makefile
@@ -0,0 +1,7 @@
+# (C) Copyright 2015 UDOO Team
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj- := __dummy__.o
+obj-y  := trim.o
diff --git a/board/udoo/common/trim.c b/board/udoo/common/trim.c
new file mode 100644
index 0000000..61ce45a
--- /dev/null
+++ b/board/udoo/common/trim.c
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) UDOO Team
+ *
+ * Author: Francesco Montefoschi <francesco.monte@gmail.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+
+int isspace(char c)
+{
+	return (c == ' ' || c == '\t' || c == '\n' || c == '\r' || c == '\12');
+}
+
+char *trim(char *str)
+{
+	char *end;
+
+	// Trim leading space
+	while(isspace(*str)) str++;
+
+	if(*str == 0)  // All spaces?
+	return str;
+
+	// Trim trailing space
+	end = str + strlen(str) - 1;
+	while(end > str && isspace(*end)) end--;
+
+	// Write new null terminator
+	*(end+1) = 0;
+
+	return str;
+}
diff --git a/board/udoo/common/trim.h b/board/udoo/common/trim.h
new file mode 100644
index 0000000..795958c
--- /dev/null
+++ b/board/udoo/common/trim.h
@@ -0,0 +1,10 @@
+/*
+ * Copyright (C) UDOO Team
+ *
+ * Author: Francesco Montefoschi <francesco.monte@gmail.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+int isspace(char c);
+char *trim(char *str);
diff --git a/board/udoo/neo/Kconfig b/board/udoo/neo/Kconfig
new file mode 100644
index 0000000..8f474df
--- /dev/null
+++ b/board/udoo/neo/Kconfig
@@ -0,0 +1,12 @@
+if TARGET_UDOO_NEO
+
+config SYS_VENDOR
+	default "udoo"
+
+config SYS_BOARD
+	default "neo"
+
+config SYS_CONFIG_NAME
+	default "udoo_neo"
+
+endif
diff --git a/board/udoo/neo/MAINTAINERS b/board/udoo/neo/MAINTAINERS
new file mode 100644
index 0000000..6379b8d
--- /dev/null
+++ b/board/udoo/neo/MAINTAINERS
@@ -0,0 +1,6 @@
+UDOO NEO BOARD
+M:	Francesco Montefoschi <francesco.montefoschi@udoo.org>
+S:	Maintained
+F:	board/udoo/neo/
+F:	include/configs/udoo_neo.h
+F:	configs/udoo_neo_defconfig
diff --git a/board/udoo/neo/Makefile b/board/udoo/neo/Makefile
new file mode 100644
index 0000000..ad49d67
--- /dev/null
+++ b/board/udoo/neo/Makefile
@@ -0,0 +1,7 @@
+# (C) Copyright 2015 UDOO Team
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := neo.o detectboard.o
+obj-$(CONFIG_SPL_BUILD)  += spl.o
diff --git a/board/udoo/neo/detectboard.c b/board/udoo/neo/detectboard.c
new file mode 100644
index 0000000..b3a7294
--- /dev/null
+++ b/board/udoo/neo/detectboard.c
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) UDOO Team
+ *
+ * Author: Francesco Montefoschi <francesco.monte@gmail.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/mx6-pins.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include "detectboard.h"
+
+#define DIO_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_34ohm | PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+#define DIO_PAD_CFG   (MUX_PAD_CTRL(DIO_PAD_CTRL) | MUX_MODE_SION)
+
+
+#define GPIO_R184 IMX_GPIO_NR(4, 13)
+#define GPIO_R185 IMX_GPIO_NR(4, 0)
+iomux_v3_cfg_t const board_recognition_pads[] = {
+    MX6_PAD_NAND_READY_B__GPIO4_IO_13 | DIO_PAD_CFG,  // Connected to R184
+    MX6_PAD_NAND_ALE__GPIO4_IO_0 | DIO_PAD_CFG,       // Connected to R185
+};
+
+/**
+ * Detects the board model by checking the R184 and R185 resistors.
+ * A mounted resistor (0Ohm) connects the GPIO to ground, so the
+ * GPIO value will be 0.
+ *
+ * FULL     - Eth, WiFi, motion sensors, 1GB RAM         -> R184 not mounted - R185 mounted
+ * EXTENDED - NO Eth, WiFi, motion sensors, 1GB RAM      -> R184 not mounted - R185 not mounted
+ * BASE     - Eth, NO WiFi, NO motion sensors, 512MB RAM -> R184 mounted     - R185 mounted
+ * BASE KS  - NO Eth, WiFi, NO motion sensors, 512MB RAM -> R184 mounted     - R185 not mounted
+ */
+int detect_board(void)
+{
+    imx_iomux_v3_setup_multiple_pads(board_recognition_pads,
+        ARRAY_SIZE(board_recognition_pads));
+
+    gpio_direction_input(GPIO_R184);
+    gpio_direction_input(GPIO_R185);
+
+    int r184 = gpio_get_value(GPIO_R184);
+    int r185 = gpio_get_value(GPIO_R185);
+
+    if (r184 == 0 && r185 == 0) {
+        return UDOO_NEO_TYPE_BASIC;
+    }
+    if (r184 == 0 && r185 == 1) {
+        return UDOO_NEO_TYPE_BASIC_KS;
+    }
+    if (r184 == 1 && r185 == 0) {
+        return UDOO_NEO_TYPE_FULL;
+    }
+    if (r184 == 1 && r185 == 1) {
+        return UDOO_NEO_TYPE_EXTENDED;
+    }
+
+    return UDOO_NEO_TYPE_FULL;
+}
\ No newline at end of file
diff --git a/board/udoo/neo/detectboard.h b/board/udoo/neo/detectboard.h
new file mode 100644
index 0000000..3cfa0c4
--- /dev/null
+++ b/board/udoo/neo/detectboard.h
@@ -0,0 +1,14 @@
+/*
+ * Copyright (C) UDOO Team
+ *
+ * Author: Francesco Montefoschi <francesco.monte@gmail.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#define UDOO_NEO_TYPE_BASIC         1
+#define UDOO_NEO_TYPE_BASIC_KS      2
+#define UDOO_NEO_TYPE_EXTENDED      3
+#define UDOO_NEO_TYPE_FULL          4
+
+int detect_board(void);
diff --git a/board/udoo/neo/neo.c b/board/udoo/neo/neo.c
new file mode 100644
index 0000000..c14733c
--- /dev/null
+++ b/board/udoo/neo/neo.c
@@ -0,0 +1,1117 @@
+/*
+ * Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
+ * Copyright (C) Jasbir Matharu
+ * Copyright (C) UDOO Team
+ *
+ * Author: Francesco Montefoschi <francesco.monte@gmail.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/io.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <linux/sizes.h>
+#include <common.h>
+#include <fsl_esdhc.h>
+#include <mmc.h>
+#include <i2c.h>
+#include <miiphy.h>
+#include <netdev.h>
+#include <power/pmic.h>
+#include <power/pfuze3000_pmic.h>
+#include <usb.h>
+#include <malloc.h>
+#include "detectboard.h"
+#include "../common/trim.h"
+
+#ifdef CONFIG_MXC_RDC
+#include <asm/imx-common/rdc-sema.h>
+#include <asm/arch/imx-rdc.h>
+#endif
+
+#ifdef CONFIG_VIDEO_MXS
+#include <linux/fb.h>
+#include <mxsfb.h>
+#endif
+
+#ifdef CONFIG_FSL_FASTBOOT
+#include <fsl_fastboot.h>
+#ifdef CONFIG_ANDROID_RECOVERY
+#include <recovery.h>
+#endif
+#endif /*CONFIG_FSL_FASTBOOT*/
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_22K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define I2C_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_PUE |            \
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |               \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS |			\
+	PAD_CTL_ODE)
+
+#define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP | PAD_CTL_PUE |     \
+	PAD_CTL_SPEED_MED   |                                   \
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST)
+
+#define ENET_CLK_PAD_CTRL  (PAD_CTL_SPEED_MED | \
+	PAD_CTL_DSE_120ohm   | PAD_CTL_SRE_FAST)
+
+#define ENET_RX_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |          \
+	PAD_CTL_SPEED_MED   | PAD_CTL_SRE_FAST)
+
+#define LCD_PAD_CTRL    (PAD_CTL_HYS | PAD_CTL_PUS_100K_UP | PAD_CTL_PUE | \
+	PAD_CTL_PKE | PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm)
+
+#define BUTTON_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_PUE | \
+	PAD_CTL_PUS_22K_UP | PAD_CTL_DSE_40ohm)
+
+#define WDOG_PAD_CTRL (PAD_CTL_PUE | PAD_CTL_PKE | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm)
+
+#define OTG_ID_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+
+#define DIO_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_34ohm | PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+#define DIO_PAD_CFG   (MUX_PAD_CTRL(DIO_PAD_CTRL) | MUX_MODE_SION)
+
+int dram_init(void)
+{
+	int ddr_mb = 1024;
+	int board_variant = detect_board();
+	if (board_variant == UDOO_NEO_TYPE_BASIC || board_variant == UDOO_NEO_TYPE_BASIC_KS) {
+		ddr_mb = 512;
+	}
+
+	gd->ram_size = ((ulong)ddr_mb * 1024 * 1024);
+
+	return 0;
+}
+
+static iomux_v3_cfg_t const uart1_pads[] = {
+	MX6_PAD_GPIO1_IO04__UART1_TX | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_GPIO1_IO05__UART1_RX | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc2_pads[] = {
+	MX6_PAD_SD2_CLK__USDHC2_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_CMD__USDHC2_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA0__USDHC2_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA1__USDHC2_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA2__USDHC2_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA3__USDHC2_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/* CD pin */
+	MX6_PAD_SD1_DATA0__GPIO6_IO_2 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* Power */
+	MX6_PAD_SD1_CMD__GPIO6_IO_1 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc3_pads[] = {
+    /* Configured for WLAN */
+	MX6_PAD_SD3_CLK__USDHC3_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_CMD__USDHC3_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA0__USDHC3_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA1__USDHC3_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA2__USDHC3_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA3__USDHC3_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const gpio_pads[] = {
+
+    MX6_PAD_NAND_DATA02__GPIO4_IO_6 | MUX_PAD_CTRL(NO_PAD_CTRL), // LED
+    MX6_PAD_SD1_CLK__GPIO6_IO_0   | MUX_PAD_CTRL(NO_PAD_CTRL),   // LED
+
+    MX6_PAD_KEY_COL3__GPIO2_IO_13 | MUX_PAD_CTRL(NO_PAD_CTRL),     // Gyro interrupt
+    MX6_PAD_NAND_WE_B__GPIO4_IO_14 | MUX_PAD_CTRL(NO_PAD_CTRL),    // Mag interrupt
+    MX6_PAD_QSPI1B_DATA2__GPIO4_IO_26 | MUX_PAD_CTRL(NO_PAD_CTRL), // Accel interrupt
+
+    MX6_PAD_SD1_DATA2__GPIO6_IO_4 | MUX_PAD_CTRL(NO_PAD_CTRL),  // Touch interrupt
+    MX6_PAD_SD1_DATA3__GPIO6_IO_5 | MUX_PAD_CTRL(NO_PAD_CTRL),  // Touch reset
+
+    MX6_PAD_NAND_READY_B__GPIO4_IO_13 | MUX_PAD_CTRL(NO_PAD_CTRL),  // recognition GPIOs - Connected to R184
+    MX6_PAD_NAND_ALE__GPIO4_IO_0 | MUX_PAD_CTRL(NO_PAD_CTRL),       // recognition GPIOs - Connected to R185
+
+    // Multiplexer pins for GPIO/ADC (J5)
+    MX6_PAD_RGMII2_TXC__GPIO5_IO_23 | MUX_PAD_CTRL(NO_PAD_CTRL),    // MUX_A
+    MX6_PAD_RGMII2_RX_CTL__GPIO5_IO_16 | MUX_PAD_CTRL(NO_PAD_CTRL), // MUX_B
+    MX6_PAD_QSPI1A_SCLK__GPIO4_IO_21 | MUX_PAD_CTRL(NO_PAD_CTRL),   // MUX_C
+    MX6_PAD_QSPI1A_SS0_B__GPIO4_IO_22 | MUX_PAD_CTRL(NO_PAD_CTRL),  // MUX_D
+    MX6_PAD_QSPI1A_DATA2__GPIO4_IO_18 | MUX_PAD_CTRL(NO_PAD_CTRL),  // MUX_E
+    MX6_PAD_QSPI1A_DATA3__GPIO4_IO_19 | MUX_PAD_CTRL(NO_PAD_CTRL),  // MUX_F
+};
+
+static iomux_v3_cfg_t const wdog_b_pad = {
+	MX6_PAD_GPIO1_IO13__GPIO1_IO_13 | MUX_PAD_CTRL(WDOG_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const peri_3v3_pads[] = {
+	MX6_PAD_QSPI1A_DATA0__GPIO4_IO_16 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_iomux_uart(void)
+{
+	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
+}
+
+#ifdef CONFIG_FEC_MXC
+static iomux_v3_cfg_t const fec1_pads[] = {
+	MX6_PAD_ENET1_MDC__ENET1_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_MDIO__ENET1_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII1_RX_CTL__ENET1_RX_EN | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII1_RD0__ENET1_RX_DATA_0 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII1_RD1__ENET1_RX_DATA_1 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII1_TX_CTL__ENET1_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII1_RXC__ENET1_RX_ER | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII1_TD0__ENET1_TX_DATA_0 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII1_TD1__ENET1_TX_DATA_1 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_TX_CLK__ENET1_REF_CLK1 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_ENET2_TX_CLK__GPIO2_IO_9 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_ENET1_CRS__GPIO2_IO_1 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const phy_control_pads[] = {
+	/* 25MHz Ethernet PHY Clock */
+	MX6_PAD_ENET2_RX_CLK__ENET2_REF_CLK_25M | MUX_PAD_CTRL(ENET_CLK_PAD_CTRL),
+};
+
+static int setup_fec(int fec_id)
+{
+	struct anatop_regs *anatop = (struct anatop_regs *)ANATOP_BASE_ADDR;
+	int reg;
+
+	imx_iomux_v3_setup_multiple_pads(phy_control_pads,
+					 ARRAY_SIZE(phy_control_pads));
+
+	/* Reset PHY */
+	gpio_direction_output(IMX_GPIO_NR(2, 1) , 0);
+	udelay(500 + 10);
+	gpio_set_value(IMX_GPIO_NR(2, 1), 1);
+	udelay(100 + 10);
+
+	reg = readl(&anatop->pll_enet);
+	reg |= BM_ANADIG_PLL_ENET_REF_25M_ENABLE;
+	writel(reg, &anatop->pll_enet);
+
+	return enable_fec_anatop_clock(fec_id, ENET_25MHZ);
+}
+
+int board_eth_init(bd_t *bis)
+{
+	uint32_t base = IMX_FEC_BASE;
+	struct mii_dev *bus = NULL;
+	struct phy_device *phydev = NULL;
+	int ret;
+
+	imx_iomux_v3_setup_multiple_pads(fec1_pads, ARRAY_SIZE(fec1_pads));
+
+	setup_fec(CONFIG_FEC_ENET_DEV);
+
+	bus = fec_get_miibus(base, CONFIG_FEC_ENET_DEV);
+	if (!bus)
+		return 0;
+
+	phydev = phy_find_by_mask(bus, (0x1 << CONFIG_FEC_MXC_PHYADDR), PHY_INTERFACE_MODE_RMII);
+
+	if (!phydev) {
+		free(bus);
+		return 0;
+	}
+	printf("using phy at %d\n", phydev->addr);
+	ret  = fec_probe(bis, CONFIG_FEC_ENET_DEV, base, bus, phydev);
+	if (ret) {
+		printf("FEC MXC: %s:failed\n", __func__);
+		free(phydev);
+		free(bus);
+	}
+	return 0;
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+#endif
+
+static void setup_iomux_gpio(void)
+{
+    imx_iomux_v3_setup_multiple_pads(gpio_pads, ARRAY_SIZE(gpio_pads));
+
+    gpio_direction_input(IMX_GPIO_NR(2,13)); // Gyro interrupt
+    gpio_direction_input(IMX_GPIO_NR(4,14)); // Mag interrupt
+    gpio_direction_input(IMX_GPIO_NR(4,26)); // Accel interupt
+    gpio_direction_input(IMX_GPIO_NR(2,4));  // Touch interrupt
+
+    gpio_direction_input(IMX_GPIO_NR(4,13));  // recognition GPIOs - Connected to R184
+    gpio_direction_input(IMX_GPIO_NR(4,0));   // recognition GPIOs - Connected to R185
+
+    gpio_direction_output(IMX_GPIO_NR(4,6), 0);	 // LED
+    gpio_direction_output(IMX_GPIO_NR(6,0), 1);  // LED
+
+    gpio_direction_output(IMX_GPIO_NR(5,23), 0); // MUX_A
+    gpio_direction_output(IMX_GPIO_NR(5,16), 0); // MUX_B
+    gpio_direction_output(IMX_GPIO_NR(4,21), 0); // MUX_C
+    gpio_direction_output(IMX_GPIO_NR(4,22), 0); // MUX_D
+    gpio_direction_output(IMX_GPIO_NR(4,18), 0); // MUX_E
+    gpio_direction_output(IMX_GPIO_NR(4,19), 0); // MUX_F
+};
+
+static iomux_v3_cfg_t const wl1831_control_pads[] = {
+	/* WL1831 - WiFi enable */
+	MX6_PAD_KEY_COL2__GPIO2_IO_12 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* WL1831 - Bt enable */
+	MX6_PAD_KEY_ROW2__GPIO2_IO_17 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_wl1831(void)
+{
+	imx_iomux_v3_setup_multiple_pads(wl1831_control_pads, ARRAY_SIZE(wl1831_control_pads));
+
+	gpio_direction_output(IMX_GPIO_NR(2,12), 0); // WL1831 - WiFi enable
+	gpio_direction_output(IMX_GPIO_NR(2,17), 0); // WL1831 - Bt enable
+}
+
+#ifdef CONFIG_VIDEO_MXS
+static iomux_v3_cfg_t const lvds_ctrl_pads[] = {
+	/* CABC enable */
+	MX6_PAD_QSPI1B_DATA3__GPIO4_IO_27 | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	/* Use GPIO for Brightness adjustment, duty cycle = period */
+	MX6_PAD_SD1_DATA1__GPIO6_IO_3 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const lcd_pads[] = {
+	MX6_PAD_LCD1_CLK__LCDIF1_CLK | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_ENABLE__LCDIF1_ENABLE | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_HSYNC__LCDIF1_HSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_VSYNC__LCDIF1_VSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA00__LCDIF1_DATA_0 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA01__LCDIF1_DATA_1 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA02__LCDIF1_DATA_2 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA03__LCDIF1_DATA_3 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA04__LCDIF1_DATA_4 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA05__LCDIF1_DATA_5 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA06__LCDIF1_DATA_6 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA07__LCDIF1_DATA_7 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA08__LCDIF1_DATA_8 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA09__LCDIF1_DATA_9 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA10__LCDIF1_DATA_10 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA11__LCDIF1_DATA_11 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA12__LCDIF1_DATA_12 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA13__LCDIF1_DATA_13 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA14__LCDIF1_DATA_14 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA15__LCDIF1_DATA_15 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA16__LCDIF1_DATA_16 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA17__LCDIF1_DATA_17 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA18__LCDIF1_DATA_18 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA19__LCDIF1_DATA_19 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA20__LCDIF1_DATA_20 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA21__LCDIF1_DATA_21 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA22__LCDIF1_DATA_22 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA23__LCDIF1_DATA_23 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_RESET__GPIO3_IO_27 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* CEC Clock */
+	MX6_PAD_GPIO1_IO12__CCM_CLKO2 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+
+struct lcd_panel_info_t {
+	unsigned int lcdif_base_addr;
+	int depth;
+	void	(*enable)(struct lcd_panel_info_t const *dev);
+	struct fb_videomode mode;
+};
+
+void do_enable_lvds(struct lcd_panel_info_t const *dev)
+{
+	enable_lcdif_clock(dev->lcdif_base_addr);
+	enable_lvds(dev->lcdif_base_addr);
+
+	imx_iomux_v3_setup_multiple_pads(lvds_ctrl_pads,
+							ARRAY_SIZE(lvds_ctrl_pads));
+
+	/* Enable CABC */
+	gpio_direction_output(IMX_GPIO_NR(4, 27) , 1);
+
+	/* Set Brightness to high */
+	gpio_direction_output(IMX_GPIO_NR(6, 3) , 1);
+}
+
+void do_enable_parallel_lcd(struct lcd_panel_info_t const *dev)
+{
+	// enable_lcdif_clock(dev->lcdif_base_addr);
+	//
+	// imx_iomux_v3_setup_multiple_pads(lcd_pads, ARRAY_SIZE(lcd_pads));
+	//
+	// /* HDMI interrupt */
+	// gpio_direction_input(IMX_GPIO_NR(3, 27));
+	//
+	// /* Set clock CCM_CLKO2 to 12MHz */
+	// struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	// int reg;
+	// reg = readl(&mxc_ccm->ccosr);
+	// reg |= (MXC_CCM_CCOSR_CKO2_EN_OFFSET  |
+	// 	1 << MXC_CCM_CCOSR_CKO2_DIV_OFFSET |
+	// 	14 << MXC_CCM_CCOSR_CKO2_SEL_OFFSET );
+	//
+	// /* Initialise HDMI controller */
+	// tda19988_init();
+	// tda19988_reset();
+	// tda19988_fb_mode(dev->mode);
+}
+
+static struct lcd_panel_info_t const displays[] = {{
+	.lcdif_base_addr = LCDIF2_BASE_ADDR,
+	.depth = 18,
+	.enable	= do_enable_lvds,
+	.mode	= {
+		.name			= "Hannstar-XGA",
+		.xres           = 1024,
+		.yres           = 768,
+		.pixclock       = 15385,
+		.left_margin    = 220,
+		.right_margin   = 40,
+		.upper_margin   = 21,
+		.lower_margin   = 7,
+		.hsync_len      = 60,
+		.vsync_len      = 10,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} }, {
+	.lcdif_base_addr = LCDIF1_BASE_ADDR,
+	.depth = 24,
+	.enable	= do_enable_parallel_lcd,
+	.mode	= {
+        /*
+         * Attached to TDA19988. For now set default resolution to
+         * 1280x720@60 this should work for both DVI and HDMI sources.
+         */
+		.name			= "MCIMX28LCD",
+		.xres           = 1280,
+		.yres           = 720,
+		.pixclock       = 13468, // 74.250 MHz
+		.left_margin    = 220,
+		.right_margin   = 110,
+		.upper_margin   = 20,
+		.lower_margin   = 5,
+		.hsync_len      = 40,
+		.vsync_len      = 5,
+		.sync           = FB_SYNC_VERT_HIGH_ACT,
+		.vmode          = FB_VMODE_NONINTERLACED
+} } };
+
+int board_video_skip(void)
+{
+	int i;
+	int ret;
+	char const *panel = getenv("panel");
+	if (!panel) {
+		panel = displays[0].mode.name;
+		printf("No panel detected: default to %s\n", panel);
+		i = 0;
+	} else {
+		for (i = 0; i < ARRAY_SIZE(displays); i++) {
+			if (!strcmp(panel, displays[i].mode.name))
+				break;
+		}
+	}
+	if (i < ARRAY_SIZE(displays)) {
+		ret = mxs_lcd_panel_setup(displays[i].mode, displays[i].depth,
+				    displays[i].lcdif_base_addr);
+		if (!ret) {
+			if (displays[i].enable)
+				displays[i].enable(displays+i);
+			printf("Display: %s (%ux%u)\n",
+			       displays[i].mode.name,
+			       displays[i].mode.xres,
+			       displays[i].mode.yres);
+		} else
+			printf("LCD %s cannot be configured: %d\n",
+			       displays[i].mode.name, ret);
+	} else {
+		printf("unsupported panel %s\n", panel);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_SYS_I2C_MXC
+#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
+/* I2C1 for PMIC */
+static struct i2c_pads_info i2c_pad_info1 = {
+	.scl = {
+		.i2c_mode = MX6_PAD_GPIO1_IO00__I2C1_SCL | PC,
+		.gpio_mode = MX6_PAD_GPIO1_IO00__GPIO1_IO_0 | PC,
+		.gp = IMX_GPIO_NR(1, 0),
+	},
+	.sda = {
+		.i2c_mode = MX6_PAD_GPIO1_IO01__I2C1_SDA | PC,
+		.gpio_mode = MX6_PAD_GPIO1_IO01__GPIO1_IO_1 | PC,
+		.gp = IMX_GPIO_NR(1, 1),
+	},
+};
+
+/* I2C3 */
+struct i2c_pads_info i2c_pad_info3 = {
+	.scl = {
+		.i2c_mode = MX6_PAD_KEY_COL4__I2C3_SCL | PC,
+		.gpio_mode = MX6_PAD_KEY_COL4__GPIO2_IO_14 | PC,
+		.gp = IMX_GPIO_NR(2, 14),
+	},
+	.sda = {
+		.i2c_mode = MX6_PAD_KEY_ROW4__I2C3_SDA | PC,
+		.gpio_mode = MX6_PAD_KEY_ROW4__GPIO2_IO_19 | PC,
+		.gp = IMX_GPIO_NR(2, 19),
+	},
+};
+
+int power_init_board(void)
+{
+	struct pmic *p;
+	int ret;
+	unsigned int reg, rev_id;
+
+	ret = power_pfuze3000_init(PFUZE3000_I2C_BUS);
+	if (ret)
+		return ret;
+
+	p = pmic_get("PFUZE3000");
+	ret = pmic_probe(p);
+	if (ret)
+		return ret;
+
+	pmic_reg_read(p, PFUZE3000_DEVICEID, &reg);
+	pmic_reg_read(p, PFUZE3000_REVID, &rev_id);
+	printf("PMIC:  PFUZE3000 DEV_ID=0x%x REV_ID=0x%x\n", reg, rev_id);
+
+	/* disable Low Power Mode during standby mode */
+	pmic_reg_read(p, PFUZE3000_LDOGCTL, &reg);
+	reg |= 0x1;
+	pmic_reg_write(p, PFUZE3000_LDOGCTL, reg);
+
+	if (pmic_reg_write(p, PFUZE3000_SW1AMODE, 0xc)) {
+		printf("PMIC: Set SW1AMODE error!\n");
+		return -1;
+	}
+
+	if (pmic_reg_write(p, PFUZE3000_SW1BMODE, 0xc)) {
+		printf("PMIC: Set SW1BMODE error!\n");
+		return -1;
+	}
+
+	if (pmic_reg_write(p, PFUZE3000_SW2MODE, 0xc)) {
+		printf("PMIC: Set SW2MODE error!\n");
+		return -1;
+	}
+
+	if (pmic_reg_write(p, PFUZE3000_SW3MODE, 0xc)) {
+		printf("PMIC: Set SW3MODE error!\n");
+		return -1;
+	}
+
+	/* set SW1A standby volatage 0.975V */
+	pmic_reg_read(p, PFUZE3000_SW1ASTBY, &reg);
+	reg &= ~0x3f;
+	reg |= PFUZE3000_SW1AB_SETP(9750);
+	if (pmic_reg_write(p, PFUZE3000_SW1ASTBY, reg)) {
+		printf("PMIC: Set SW1ASTBY error!\n");
+		return -1;
+	}
+
+	/* set SW1B standby volatage 0.975V */
+	pmic_reg_read(p, PFUZE3000_SW1BSTBY, &reg);
+	reg &= ~0x3f;
+	reg |= PFUZE3000_SW1AB_SETP(9750);
+	if (pmic_reg_write(p, PFUZE3000_SW1BSTBY, reg)) {
+		printf("PMIC: Set SW1BSTBY error!\n");
+		return -1;
+	}
+
+	/* set SW1A/VDD_ARM_IN step ramp up time from 16us to 4us/25mV */
+	pmic_reg_read(p, PFUZE3000_SW1ACONF, &reg);
+	reg &= ~0xc0;
+	reg |= 0x40;
+	if (pmic_reg_write(p, PFUZE3000_SW1ACONF, reg)) {
+		printf("PMIC: Set SW1ACONF error!\n");
+		return -1;
+	}
+
+	/* set SW1B/VDD_SOC_IN step ramp up time from 16us to 4us/25mV */
+	pmic_reg_read(p, PFUZE3000_SW1BCONF, &reg);
+	reg &= ~0xc0;
+	reg |= 0x40;
+	if (pmic_reg_write(p, PFUZE3000_SW1BCONF, reg)) {
+		printf("PMIC: Set SW1BCONF error!\n");
+		return -1;
+	}
+
+	/* set VDD_ARM_IN to 1.350V */
+	pmic_reg_read(p, PFUZE3000_SW1AVOLT, &reg);
+	reg &= ~0x3f;
+	reg |= PFUZE3000_SW1AB_SETP(13500);
+	if (pmic_reg_write(p, PFUZE3000_SW1AVOLT, reg)) {
+		printf("PMIC: Set SW1AVOLT error!\n");
+		return -1;
+	}
+
+	/* set VDD_SOC_IN to 1.350V */
+	pmic_reg_read(p, PFUZE3000_SW1BVOLT, &reg);
+	reg &= ~0x3f;
+	reg |= PFUZE3000_SW1AB_SETP(13500);
+	if (pmic_reg_write(p, PFUZE3000_SW1BVOLT, reg)) {
+		printf("PMIC: Set SW1BVOLT error!\n");
+		return -1;
+	}
+
+	/* set DDR_1_5V to 1.350V */
+	pmic_reg_read(p, PFUZE3000_SW3VOLT, &reg);
+	reg &= ~0x0f;
+	reg |= PFUZE3000_SW3_SETP(13500);
+	if (pmic_reg_write(p, PFUZE3000_SW3VOLT, reg)) {
+		printf("PMIC: Set SW3VOLT error!\n");
+		return -1;
+	}
+
+	/* set VGEN2_1V5 to 1.5V */
+	pmic_reg_read(p, PFUZE3000_VLDO2CTL, &reg);
+	reg &= ~0x0f;
+	reg |= PFUZE3000_VLDO_SETP(15000);
+	/*  enable  */
+	reg |= 0x10;
+	if (pmic_reg_write(p, PFUZE3000_VLDO2CTL, reg)) {
+		printf("PMIC: Set VLDO2CTL error!\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_LDO_BYPASS_CHECK
+void ldo_mode_set(int ldo_bypass)
+{
+	unsigned int reg;
+	int is_400M;
+	u32 vddarm;
+	struct pmic *p;
+
+	/* switch to ldo_bypass mode */
+	if (ldo_bypass) {
+		prep_anatop_bypass();
+
+		p = pmic_get("PFUZE3000");
+
+		/* set VDD_ARM_IN to 1.350V */
+		pmic_reg_read(p, PFUZE3000_SW1AVOLT, &reg);
+		reg &= ~0x3f;
+		reg |= PFUZE3000_SW1AB_SETP(13500);
+		if (pmic_reg_write(p, PFUZE3000_SW1AVOLT, reg)) {
+			printf("PMIC: Set SW1AVOLT error!\n");
+			return;
+		}
+
+		/* set VDD_SOC_IN to 1.350V */
+		pmic_reg_read(p, PFUZE3000_SW1BVOLT, &reg);
+		reg &= ~0x3f;
+		reg |= PFUZE3000_SW1AB_SETP(13500);
+		if (pmic_reg_write(p, PFUZE3000_SW1BVOLT, reg)) {
+			printf("PMIC: Set SW1BVOLT error!\n");
+			return;
+		}
+
+		is_400M = set_anatop_bypass(1);
+		if (is_400M)
+			vddarm = PFUZE3000_SW1AB_SETP(10750);
+		else
+			vddarm = PFUZE3000_SW1AB_SETP(11750);
+
+		pmic_reg_read(p, PFUZE3000_SW1AVOLT, &reg);
+		reg &= ~0x3f;
+		reg |= vddarm;
+		if (pmic_reg_write(p, PFUZE3000_SW1AVOLT, reg)) {
+			printf("PMIC: Set SW1AVOLT error!\n");
+			return;
+		}
+
+		pmic_reg_read(p, PFUZE3000_SW1BVOLT, &reg);
+		reg &= ~0x3f;
+		reg |= PFUZE3000_SW1AB_SETP(11750);
+		if (pmic_reg_write(p, PFUZE3000_SW1BVOLT, reg)) {
+			printf("PMIC: Set SW1BVOLT error!\n");
+			return;
+		}
+
+		finish_anatop_bypass();
+		printf("Switched to ldo_bypass mode!\n");
+	}
+
+}
+#endif
+#endif
+
+#ifdef CONFIG_MXC_RDC
+static rdc_peri_cfg_t const shared_resources[] = {
+	(RDC_PER_GPIO1 | RDC_DOMAIN(0) | RDC_DOMAIN(1)),
+};
+#endif
+
+#ifdef CONFIG_USB_EHCI_MX6
+#define USB_OTHERREGS_OFFSET	0x800
+#define UCTRL_PWR_POL		(1 << 9)
+
+static iomux_v3_cfg_t const usb_otg_pads[] = {
+	/* OGT1 */
+	MX6_PAD_GPIO1_IO09__USB_OTG1_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_GPIO1_IO10__ANATOP_OTG1_ID | MUX_PAD_CTRL(OTG_ID_PAD_CTRL),
+	/* OTG2 */
+	MX6_PAD_GPIO1_IO12__USB_OTG2_PWR | MUX_PAD_CTRL(NO_PAD_CTRL)
+};
+
+static void setup_usb(void)
+{
+	imx_iomux_v3_setup_multiple_pads(usb_otg_pads,
+					 ARRAY_SIZE(usb_otg_pads));
+}
+
+int board_usb_phy_mode(int port)
+{
+	if (port == 1)
+		return USB_INIT_HOST;
+	else
+		return usb_phy_mode(port);
+}
+
+int board_ehci_hcd_init(int port)
+{
+	u32 *usbnc_usb_ctrl;
+
+	if (port > 1)
+		return -EINVAL;
+
+	usbnc_usb_ctrl = (u32 *)(USB_BASE_ADDR + USB_OTHERREGS_OFFSET +
+				 port * 4);
+
+	/* Set Power polarity */
+	setbits_le32(usbnc_usb_ctrl, UCTRL_PWR_POL);
+
+	return 0;
+}
+#endif
+
+int board_early_init_f(void)
+{
+#ifdef CONFIG_MXC_RDC
+	imx_rdc_setup_peripherals(shared_resources, ARRAY_SIZE(shared_resources));
+#endif
+
+#ifdef CONFIG_SYS_AUXCORE_FASTUP
+	arch_auxiliary_core_up(0, CONFIG_SYS_AUXCORE_BOOTDATA);
+#endif
+
+	setup_iomux_uart();
+
+	return 0;
+}
+
+static struct fsl_esdhc_cfg usdhc_cfg[2] = {
+	{USDHC2_BASE_ADDR, 0, 4},
+	{USDHC3_BASE_ADDR, 0, 4},
+};
+
+#define USDHC2_PWR_GPIO IMX_GPIO_NR(6, 1)
+#define USDHC2_CD_GPIO	IMX_GPIO_NR(6, 2)
+
+int mmc_get_env_devno(void)
+{
+	u32 soc_sbmr = readl(SRC_BASE_ADDR + 0x4);
+	int dev_no;
+	u32 bootsel;
+
+	bootsel = (soc_sbmr & 0x000000FF) >> 6 ;
+
+	/* If not boot from sd/mmc, use default value */
+	if (bootsel != 1)
+		return CONFIG_SYS_MMC_ENV_DEV;
+
+	/* BOOT_CFG2[3] and BOOT_CFG2[4] */
+	dev_no = (soc_sbmr & 0x00001800) >> 11;
+
+	/* need ubstract 1 to map to the mmc device id
+	 * see the comments in board_mmc_init function
+	 */
+
+	dev_no--;
+
+	return dev_no;
+}
+
+int mmc_map_to_kernel_blk(int dev_no)
+{
+	return dev_no + 1;
+}
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC2_BASE_ADDR:
+		ret = !gpio_get_value(USDHC2_CD_GPIO);
+		break;
+	}
+
+	return ret;
+}
+
+int board_mmc_init(bd_t *bis)
+{
+#ifndef CONFIG_SPL_BUILD
+	int i, ret;
+
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-boot device node)    (Physical Port)
+	 * mmc0                    USDHC2
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc2_pads, ARRAY_SIZE(usdhc2_pads));
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+			gpio_direction_input(USDHC2_CD_GPIO);
+			gpio_direction_output(USDHC2_PWR_GPIO, 1);
+			break;
+		case 1:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc3_pads, ARRAY_SIZE(usdhc3_pads));
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+			break;
+		default:
+			printf("Warning: you configured more USDHC controllers"
+				"(%d) than supported by the board\n", i + 1);
+			return -EINVAL;
+			}
+
+			ret = fsl_esdhc_initialize(bis, &usdhc_cfg[i]);
+			if (ret) {
+				printf("Warning: failed to initialize mmc dev %d\n", i);
+				return ret;
+			}
+	}
+
+	return 0;
+#else
+	struct src *src_regs = (struct src *)SRC_BASE_ADDR;
+	u32 val;
+	u32 port;
+
+	val = readl(&src_regs->sbmr1);
+
+	if ((val & 0xc0) != 0x40) {
+		printf("Not boot from USDHC!\n");
+		return -EINVAL;
+	}
+
+	port = (val >> 11) & 0x3;
+	printf("port %d\n", port);
+	switch (port) {
+	case 1:
+		imx_iomux_v3_setup_multiple_pads(
+			usdhc2_pads, ARRAY_SIZE(usdhc2_pads));
+		usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+		usdhc_cfg[0].esdhc_base = USDHC2_BASE_ADDR;
+		gpio_direction_input(USDHC2_CD_GPIO);
+		gpio_direction_output(USDHC2_PWR_GPIO, 1);
+		break;
+	case 2:
+		imx_iomux_v3_setup_multiple_pads(
+			usdhc3_pads, ARRAY_SIZE(usdhc3_pads));
+		usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+		usdhc_cfg[1].esdhc_base = USDHC3_BASE_ADDR;
+		break;
+	}
+
+	gd->arch.sdhc_clk = usdhc_cfg[0].sdhc_clk;
+	return fsl_esdhc_initialize(bis, &usdhc_cfg[0]);
+#endif
+}
+
+int check_mmc_autodetect(void)
+{
+	char *autodetect_str = getenv("mmcautodetect");
+
+	if ((autodetect_str != NULL) &&
+		(strcmp(autodetect_str, "yes") == 0)) {
+		return 1;
+	}
+
+	return 0;
+}
+
+void board_late_mmc_init(void)
+{
+	char cmd[32];
+	char mmcblk[32];
+	u32 dev_no = mmc_get_env_devno();
+
+	if (!check_mmc_autodetect())
+		return;
+
+	setenv_ulong("mmcdev", dev_no);
+
+	/* Set mmcblk env */
+	sprintf(mmcblk, "/dev/mmcblk%dp2 rootwait rw",
+		mmc_map_to_kernel_blk(dev_no));
+	setenv("mmcroot", mmcblk);
+
+	sprintf(cmd, "mmc dev %d", dev_no);
+	run_command(cmd, 0);
+}
+
+#ifdef CONFIG_FSL_QSPI
+
+#define QSPI_PAD_CTRL1	\
+	(PAD_CTL_SRE_FAST | PAD_CTL_SPEED_HIGH | \
+	 PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_47K_UP | PAD_CTL_DSE_40ohm)
+
+static iomux_v3_cfg_t const quadspi_pads[] = {
+	MX6_PAD_NAND_WP_B__QSPI2_A_DATA_0	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_READY_B__QSPI2_A_DATA_1	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CE0_B__QSPI2_A_DATA_2	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CE1_B__QSPI2_A_DATA_3	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_ALE__QSPI2_A_SS0_B		| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CLE__QSPI2_A_SCLK		| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+};
+
+int board_qspi_init(void)
+{
+	/* Set the iomux */
+	imx_iomux_v3_setup_multiple_pads(quadspi_pads,
+					 ARRAY_SIZE(quadspi_pads));
+
+	/* Set the clock */
+	enable_qspi_clk(1);
+
+	return 0;
+}
+#endif
+
+int board_init(void)
+{
+	/* Address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+	/*
+	 * Because kernel set WDOG_B mux before pad with the commone pinctrl
+	 * framwork now and wdog reset will be triggered once set WDOG_B mux
+	 * with default pad setting, we set pad setting here to workaround this.
+	 * Since imx_iomux_v3_setup_pad also set mux before pad setting, we set
+	 * as GPIO mux firstly here to workaround it.
+	 */
+	imx_iomux_v3_setup_pad(wdog_b_pad);
+
+	/* Enable PERI_3V3, which is used by SD2, ENET, LVDS, BT */
+	imx_iomux_v3_setup_multiple_pads(peri_3v3_pads,
+					 ARRAY_SIZE(peri_3v3_pads));
+
+	/* Active high for ncp692 */
+	gpio_direction_output(IMX_GPIO_NR(4, 16) , 1);
+
+	setup_iomux_gpio();
+
+#ifdef CONFIG_SYS_I2C_MXC
+	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+	setup_i2c(2, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info3);
+#endif
+
+#ifdef CONFIG_USB_EHCI_MX6
+	setup_usb();
+#endif
+
+#ifdef CONFIG_FSL_QSPI
+	board_qspi_init();
+#endif
+
+	setup_wl1831();
+
+	return 0;
+}
+
+int board_late_init(void)
+{
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_init();
+#endif
+
+	return 0;
+}
+
+u32 get_board_rev(void)
+{
+	return get_cpu_rev();
+}
+
+int checkboard(void)
+{
+	int board_variant = detect_board();
+
+	if (board_variant == UDOO_NEO_TYPE_BASIC) {
+		puts("Board: UDOO Neo Basic\n");
+	}
+	if (board_variant == UDOO_NEO_TYPE_BASIC_KS) {
+		puts("Board: UDOO Neo Basic (Kickstarter Edition)\n");
+	}
+	if (board_variant == UDOO_NEO_TYPE_EXTENDED) {
+		puts("Board: UDOO Neo Extended\n");
+	}
+	if (board_variant == UDOO_NEO_TYPE_FULL) {
+		puts("Board: UDOO Neo Full\n");
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_FSL_FASTBOOT
+
+void board_fastboot_setup(void)
+{
+	if (!getenv("mmc_cur"))
+		setenv("mmc_cur", "0");
+	if (!getenv("fastboot_dev"))
+		setenv("fastboot_dev", "mmc0");
+	if (!getenv("bootcmd"))
+		setenv("bootcmd", "run udoo_boot_init; boota mmc0");
+}
+
+#ifdef CONFIG_ANDROID_RECOVERY
+
+int check_recovery_cmd_file(void)
+{
+	return recovery_check_and_clean_flag();
+}
+
+void board_recovery_setup(void)
+{
+	printf("setup env for recovery..\n");
+	setenv("bootcmd", "run recoverycmd");
+}
+#endif /*CONFIG_ANDROID_RECOVERY*/
+
+#endif /*CONFIG_FSL_FASTBOOT*/
+
+/**
+ * After loading uEnv.txt, we autodetect which fdt file we need to load and if we should start M4.
+ * uEnv.txt can contain:
+ *  - video_output=hdmi|lvds7|lvds15|disabled
+ *    any other value (or if the variable is not specified) will default to "hdmi"
+ *  - m4_enabled=true|false
+ *    any other value (or if the variable is not specified) will default to "true"
+ *  - use_custom_dtb=true|false
+ *    any other value (or if the variable is not specified) will default to "false"
+ *
+ * Despite the signature, this command does not accept any argument.
+ */
+int do_udooinit(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int board_variant = detect_board();
+	char* modelfdt;
+
+	switch (board_variant) {
+		case UDOO_NEO_TYPE_BASIC:
+			modelfdt = "imx6sx-udoo-neo-basic";
+			break;
+		case UDOO_NEO_TYPE_BASIC_KS:
+			modelfdt = "imx6sx-udoo-neo-basicks";
+			break;
+		case UDOO_NEO_TYPE_EXTENDED:
+			modelfdt = "imx6sx-udoo-neo-extended";
+			break;
+		case UDOO_NEO_TYPE_FULL:
+			modelfdt = "imx6sx-udoo-neo-full";
+			break;
+		default:
+			return 0;
+	}
+
+	char* video_part = "-hdmi";
+	char* video = getenv("video_output");
+
+	if (video) {
+		video = trim(video);
+		if (strcmp(video, "lvds7") == 0) {
+			video_part = "-lvds7";
+#ifdef CONFIG_ANDROID_SUPPORT
+			setenv("lcd_density", "128");
+#endif
+		} else if (strcmp(video, "lvds15") == 0) {
+			video_part = "-lvds15";
+		} else if (strcmp(video, "disabled") == 0) {
+			video_part = "";
+		}
+	}
+
+	char* actual_fdt = getenv("fdt_file");
+	if (actual_fdt) {
+		actual_fdt = trim(actual_fdt);
+		if (strcmp(actual_fdt, "autodetect") != 0) {
+			// if fdt_file is already set, do not overwrite it!
+			return 0;
+		}
+	}
+
+	char* m4_part = "-m4";
+	char* m4 = getenv("m4_enabled");
+	if (m4) {
+		m4 = trim(m4);
+		if (strcmp(m4, "false") == 0 || strcmp(m4, "no") == 0 || strcmp(m4, "disabled") == 0) {
+			m4_part = "";
+			printf("M4: disabled via environment variables.\n");
+		}
+	}
+
+	char fdt_file[100];
+	char* customdtb = getenv("use_custom_dtb");
+	sprintf(fdt_file, "/boot/%s%s%s.dtb", modelfdt, video_part, m4_part);
+	if (customdtb) {
+		customdtb = trim(customdtb);
+		if (strcmp(customdtb, "true") == 0 || strcmp(customdtb, "yes") == 0 || strcmp(customdtb, "enabled") == 0) {
+			char* dir_part = "dts-overlay";
+			sprintf(fdt_file, "/boot/%s/%s%s%s.dtb", dir_part, modelfdt, video_part, m4_part);
+		}
+	}
+
+	printf("Device Tree: %s\n", fdt_file);
+	setenv("fdt_file", fdt_file);
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	udooinit,	1,	1,	do_udooinit,
+	"(UDOO Neo) initialize M4 core and determine the device tree to load", ""
+);
diff --git a/board/udoo/neo/spl.c b/board/udoo/neo/spl.c
new file mode 100644
index 0000000..e0e1b1c
--- /dev/null
+++ b/board/udoo/neo/spl.c
@@ -0,0 +1,175 @@
+/*
+ * Copyright (C) UDOO Team
+ *
+ * Author: Francesco Montefoschi <francesco.monte@gmail.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/io.h>
+#include <linux/sizes.h>
+#include <common.h>
+#include <libfdt.h>
+#include <spl.h>
+#include <asm/arch/mx6-ddr.h>
+#include "detectboard.h"
+
+const struct mx6sx_iomux_ddr_regs mx6_ddr_ioregs = {
+	.dram_dqm0 = 0x00000028,
+	.dram_dqm1 = 0x00000028,
+	.dram_dqm2 = 0x00000028,
+	.dram_dqm3 = 0x00000028,
+	.dram_ras = 0x00000020,
+	.dram_cas = 0x00000020,
+	.dram_odt0 = 0x00000020,
+	.dram_odt1 = 0x00000020,
+	.dram_sdba2 = 0x00000000,
+	.dram_sdcke0 = 0x00003000,
+	.dram_sdcke1 = 0x00003000,
+	.dram_sdclk_0 = 0x00000030,
+	.dram_sdqs0 = 0x00000028,
+	.dram_sdqs1 = 0x00000028,
+	.dram_sdqs2 = 0x00000028,
+	.dram_sdqs3 = 0x00000028,
+	.dram_reset = 0x00000020,
+};
+
+const struct mx6sx_iomux_grp_regs mx6_grp_ioregs = {
+	.grp_addds = 0x00000020,
+	.grp_ddrmode_ctl = 0x00020000,
+	.grp_ddrpke = 0x00000000,
+	.grp_ddrmode = 0x00020000,
+	.grp_b0ds = 0x00000028,
+	.grp_b1ds = 0x00000028,
+	.grp_ctlds = 0x00000020,
+	.grp_ddr_type = 0x000c0000,
+	.grp_b2ds = 0x00000028,
+	.grp_b3ds = 0x00000028,
+};
+
+const struct mx6_mmdc_calibration neo_mmcd_calib = {
+	.p0_mpwldectrl0 = 0x000E000B,
+	.p0_mpwldectrl1 = 0x000E0010,
+	.p0_mpdgctrl0 = 0x41600158,
+	.p0_mpdgctrl1 = 0x01500140,
+	.p0_mprddlctl = 0x3A383E3E,
+	.p0_mpwrdlctl = 0x3A383C38,
+};
+
+const struct mx6_mmdc_calibration neo_basic_mmcd_calib = {
+	.p0_mpwldectrl0 = 0x001E0022,
+	.p0_mpwldectrl1 = 0x001C0019,
+	.p0_mpdgctrl0 = 0x41540150,
+	.p0_mpdgctrl1 = 0x01440138,
+	.p0_mprddlctl = 0x403E4644,
+	.p0_mpwrdlctl = 0x3C3A4038,
+};
+
+/* MT41K256M16 */
+static struct mx6_ddr3_cfg neo_mem_ddr = {
+	.mem_speed = 1600,
+	.density = 4,
+	.width = 32,
+	.banks = 8,
+	.rowaddr = 15,
+	.coladdr = 10,
+	.pagesz = 2,
+	.trcd = 1375,
+	.trcmin = 4875,
+	.trasmin = 3500,
+};
+
+/* MT41K128M16 */
+static struct mx6_ddr3_cfg neo_basic_mem_ddr = {
+	.mem_speed = 1600,
+	.density = 2,
+	.width = 16,
+	.banks = 8,
+	.rowaddr = 14,
+	.coladdr = 10,
+	.pagesz = 2,
+	.trcd = 1375,
+	.trcmin = 4875,
+	.trasmin = 3500,
+};
+
+static void ccgr_init(void)
+{
+	struct mxc_ccm_reg *ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	writel(0xFFFFFFFF, &ccm->CCGR0);
+	writel(0xFFFFFFFF, &ccm->CCGR1);
+	writel(0xFFFFFFFF, &ccm->CCGR2);
+	writel(0xFFFFFFFF, &ccm->CCGR3);
+	writel(0xFFFFFFFF, &ccm->CCGR4);
+	writel(0xFFFFFFFF, &ccm->CCGR5);
+	writel(0xFFFFFFFF, &ccm->CCGR6);
+	writel(0xFFFFFFFF, &ccm->CCGR7);
+}
+
+static void spl_dram_init(void)
+{
+	int board = detect_board();
+
+	struct mx6_ddr_sysinfo sysinfo = {
+		.dsize = neo_mem_ddr.width/32,
+		.cs_density = 24,
+		.ncs = 1,
+		.cs1_mirror = 0,
+		.rtt_wr = 2,
+		.rtt_nom = 2,		/* RTT_Nom = RZQ/2 */
+		.walat = 1,		/* Write additional latency */
+		.ralat = 5,		/* Read additional latency */
+		.mif3_mode = 3,		/* Command prediction working mode */
+		.bi_on = 1,		/* Bank interleaving enabled */
+		.sde_to_rst = 0x10,	/* 14 cycles, 200us (JEDEC default) */
+		.rst_to_cke = 0x23,	/* 33 cycles, 500us (JEDEC default) */
+	};
+
+	if (board == UDOO_NEO_TYPE_BASIC || board == UDOO_NEO_TYPE_BASIC_KS) {
+		puts("Seting 512MB RAM calibration data\n");
+		mx6sx_dram_iocfg(neo_basic_mem_ddr.width, &mx6_ddr_ioregs, &mx6_grp_ioregs);
+		sysinfo.dsize = neo_basic_mem_ddr.width/32;
+		mx6_dram_cfg(&sysinfo, &neo_basic_mmcd_calib, &neo_basic_mem_ddr);
+		((struct mmdc_p_regs *)MX6_MMDC_P0_MDCTL)->mdctl = 0x83190000;
+	} else {
+		puts("Setting 1024MB RAM calibration data\n");
+		mx6sx_dram_iocfg(neo_mem_ddr.width, &mx6_ddr_ioregs, &mx6_grp_ioregs);
+		mx6_dram_cfg(&sysinfo, &neo_mmcd_calib, &neo_mem_ddr);
+		((struct mmdc_p_regs *)MX6_MMDC_P0_MDCTL)->mdctl = 0x84190000;
+	}
+}
+
+void board_init_f(ulong dummy)
+{
+	/* setup AIPS and disable watchdog */
+	arch_cpu_init();
+
+	ccgr_init();
+
+	/* iomux and setup of i2c */
+	board_early_init_f();
+
+	/* setup GP timer */
+	timer_init();
+
+	/* UART clocks enabled and gd valid - init serial console */
+	preloader_console_init();
+
+	/* DDR initialization */
+	spl_dram_init();
+
+	/* Clear the BSS. */
+	memset(__bss_start, 0, __bss_end - __bss_start);
+
+	/* load/boot image from boot device */
+	board_init_r(NULL, 0);
+}
+
+void reset_cpu(ulong addr)
+{
+}
diff --git a/board/udoo/quad_dual/Makefile b/board/udoo/quad_dual/Makefile
index 1d6d9f8..18f5bf9 100644
--- a/board/udoo/quad_dual/Makefile
+++ b/board/udoo/quad_dual/Makefile
@@ -4,4 +4,5 @@
 # SPDX-License-Identifier:	GPL-2.0+
 #
 
-obj-y  := udoo.o udoo_spl.o
+obj-y  := udoo.o
+obj-$(CONFIG_SPL_BUILD)  += udoo_spl.o
diff --git a/board/udoo/quad_dual/udoo.c b/board/udoo/quad_dual/udoo.c
index 8773985..50a2dc6 100644
--- a/board/udoo/quad_dual/udoo.c
+++ b/board/udoo/quad_dual/udoo.c
@@ -24,6 +24,7 @@
 #include <micrel.h>
 #include <miiphy.h>
 #include <netdev.h>
+#include "../common/trim.h"
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -282,31 +283,6 @@ int checkboard(void)
 	return 0;
 }
 
-
-int isspace(char c)
-{
-	return (c == ' ' || c == '\t' || c == '\n' || c == '\r' || c == '\12');
-}
-char *trim(char *str)
-{
-	char *end;
-
-	// Trim leading space
-	while(isspace(*str)) str++;
-
-	if(*str == 0)  // All spaces?
-	return str;
-
-	// Trim trailing space
-	end = str + strlen(str) - 1;
-	while(end > str && isspace(*end)) end--;
-
-	// Write new null terminator
-	*(end+1) = 0;
-
-	return str;
-}
-
 /**
  * After loading uEnv.txt, we autodetect which fdt file we need to load.
  * uEnv.txt can contain:
@@ -339,17 +315,26 @@ int do_udooinit(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 		}
 	}
 
-	char* dir_part = "dts";
+	char* actual_fdt = getenv("fdt_file");
+	if (actual_fdt) {
+		actual_fdt = trim(actual_fdt);
+		if (strcmp(actual_fdt, "autodetect") != 0) {
+			// if fdt_file is already set, do not overwrite it!
+			return 0;
+		}
+	}
+
+	char fdt_file[100];
 	char* customdtb = getenv("use_custom_dtb");
+	sprintf(fdt_file, "/boot/%s%s.dtb", modelfdt, video_part);
 	if (customdtb) {
 		customdtb = trim(customdtb);
 		if (strcmp(customdtb, "true") == 0 || strcmp(customdtb, "yes") == 0 || strcmp(customdtb, "enabled") == 0) {
-			dir_part = "dts-overlay";
+			char* dir_part = "dts-overlay";
+			sprintf(fdt_file, "/boot/%s/%s%s.dtb", dir_part, modelfdt, video_part);
 		}
 	}
 
-	char fdt_file[100];
-	sprintf(fdt_file, "/boot/%s/%s%s.dtb", dir_part, modelfdt, video_part);
 
 	printf("Device Tree: %s\n", fdt_file);
 	setenv("fdt_file", fdt_file);
diff --git a/configs/udoo_neo_defconfig b/configs/udoo_neo_defconfig
new file mode 100644
index 0000000..8791906
--- /dev/null
+++ b/configs/udoo_neo_defconfig
@@ -0,0 +1,33 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_UDOO_NEO=y
+CONFIG_SPL_GPIO_SUPPORT=y
+CONFIG_SPL_LIBCOMMON_SUPPORT=y
+CONFIG_SPL_LIBGENERIC_SUPPORT=y
+CONFIG_SPL_EXT_SUPPORT=y
+CONFIG_SPL_I2C_SUPPORT=y
+CONFIG_SPL_LIBDISK_SUPPORT=y
+CONFIG_SPL_MMC_SUPPORT=y
+CONFIG_SPL_SERIAL_SUPPORT=y
+CONFIG_SPL_WATCHDOG_SUPPORT=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=arch/arm/imx-common/spl_sd.cfg,MX6SX"
+CONFIG_BOOTDELAY=3
+CONFIG_SPL=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_DM=y
+CONFIG_DM_THERMAL=y
+CONFIG_OF_LIBFDT=y
diff --git a/include/configs/udoo_neo.h b/include/configs/udoo_neo.h
new file mode 100644
index 0000000..c454862
--- /dev/null
+++ b/include/configs/udoo_neo.h
@@ -0,0 +1,213 @@
+/*
+ * Copyright 2014-2015 Freescale Semiconductor, Inc.
+ * Copyright Jasbir Matharu
+ * Copyright 2015 UDOO Team
+ *
+ * Configuration settings for the UDOO NEO board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#ifdef CONFIG_SPL
+#define CONFIG_SPL_ENV_SUPPORT
+#include "imx6_spl.h"
+#endif
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(3 * SZ_1M)
+
+#define CONFIG_BOARD_EARLY_INIT_F
+#define CONFIG_BOARD_LATE_INIT
+
+#define CONFIG_MXC_UART
+#define CONFIG_MXC_UART_BASE		UART1_BASE
+
+/* Linux only */
+#define CONFIG_MFG_ENV_SETTINGS \
+	"mfgtool_args=setenv bootargs console=${console},${baudrate} " \
+		"rdinit=/linuxrc " \
+		"g_mass_storage.stall=0 g_mass_storage.removable=1 " \
+		"g_mass_storage.idVendor=0x066F g_mass_storage.idProduct=0x37FF "\
+		"g_mass_storage.iSerialNumber=\"\" "\
+		"\0" \
+	"initrd_addr=0x83800000\0" \
+	"initrd_high=0xffffffff\0" \
+	"bootcmd_mfg=run mfgtool_args;bootz ${loadaddr} ${initrd_addr} ${fdt_addr};\0" \
+
+/* Linux only */
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	"script=/boot/uEnv.txt\0" \
+	"image=/boot/zImage\0" \
+	"console=ttymxc0\0" \
+	"fdt_high=0xffffffff\0" \
+	"initrd_high=0xffffffff\0" \
+	"fdt_file=autodetect\0" \
+	"fdt_addr=0x83000000\0" \
+	"boot_fdt=try\0" \
+	"ip_dyn=yes\0" \
+	"mmcdev=0\0" \
+	"mmcpart=1\0" \
+	"mmcrootfstype=ext4\0" \
+	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
+	"mmcautodetect=no\0" \
+	"mmcargs=setenv bootargs console=${console},${baudrate} " \
+		"root=${mmcroot} rootfstype=${mmcrootfstype} ${m4mmcargs} consoleblank=0\0" \
+	"m4mmcargs=uart_from_osc clk_ignore_unused cpuidle.off=1\0" \
+	"loadbootscript=" \
+		"ext2load mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
+	"bootscript=echo Running bootscript from mmc ...; " \
+		"env import -t ${loadaddr} ${filesize};\0" \
+	"loadimage=ext2load mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image}\0" \
+	"loadfdt=ext2load mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"run mmcargs; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if run loadfdt; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0" \
+	"netargs=setenv bootargs console=${console},${baudrate} " \
+		"root=/dev/nfs " \
+	"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp\0" \
+		"netboot=echo Booting from net ...; " \
+		"run netargs; " \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"${get_cmd} ${image}; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if ${get_cmd} ${fdt_addr} ${fdt_file}; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0"
+
+/* Linux only */
+#define CONFIG_BOOTCOMMAND \
+	"mmc dev ${mmcdev}; " \
+	"if mmc rescan; then " \
+		"if run loadbootscript; then " \
+			"run bootscript; " \
+		"fi; " \
+		"udooinit; " \
+		"if run loadimage; then " \
+			"run mmcboot; " \
+		"else run netboot; " \
+		"fi; " \
+	"else run netboot; fi"
+
+/* Miscellaneous configurable options */
+#define CONFIG_SYS_MEMTEST_START	0x80000000
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START + 0x10000)
+
+#define CONFIG_STACKSIZE		SZ_128K
+
+/* Physical Memory Map */
+#define CONFIG_NR_DRAM_BANKS		1
+#define PHYS_SDRAM			MMDC0_ARB_BASE_ADDR
+
+#define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM
+#define CONFIG_SYS_INIT_RAM_ADDR	IRAM_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_SIZE	IRAM_SIZE
+
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+/* MMC Configuration */
+#define CONFIG_SYS_FSL_ESDHC_ADDR	USDHC2_BASE_ADDR
+
+/* I2C Configs */
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC
+#define CONFIG_SYS_I2C_MXC_I2C1		/* enable I2C bus 1 */
+#define CONFIG_SYS_I2C_MXC_I2C3		/* enable I2C bus 3 */
+#define CONFIG_SYS_I2C_SPEED		100000
+
+/* PMIC */
+#define CONFIG_POWER
+#define CONFIG_POWER_I2C
+#define CONFIG_POWER_PFUZE3000
+#define CONFIG_POWER_PFUZE3000_I2C_ADDR	0x08
+#define PFUZE3000_I2C_BUS	0
+#define PFUZE3000_SW1AB_SETP(x)    ((x - 7000) / 250)
+#define PFUZE3000_SW3_SETP(x)      ((x - 9000) / 500)
+#define PFUZE3000_VLDO_SETP(x)     ((x - 8000) / 500)
+
+/* Network */
+#define CONFIG_FEC_MXC
+#define CONFIG_MII
+
+#define CONFIG_FEC_ENET_DEV 0
+#define IMX_FEC_BASE			ENET_BASE_ADDR
+#define CONFIG_FEC_MXC_PHYADDR          0x0
+
+#define CONFIG_FEC_XCV_TYPE             RMII
+#define CONFIG_ETHPRIME                 "FEC0"
+
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_MICREL
+
+#define CONFIG_ENV_OFFSET		(8 * SZ_64K)
+#define CONFIG_ENV_SIZE			SZ_8K
+#define CONFIG_ENV_IS_IN_MMC
+
+#define CONFIG_MMCROOT			"/dev/mmcblk0p1"  /* USDHC2 */
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_SYS_MMC_ENV_DEV		0  /*USDHC2*/
+#endif
+
+#if defined(CONFIG_ANDROID_SUPPORT)
+#define CONFIG_OF_LOAD_MANUALLY
+#define CONFIG_CMD_BOOTI
+#include "mx6sxsabresdandroid.h"
+#endif
+
+#if defined(CONFIG_ANDROID_SUPPORT)
+#undef CONFIG_EXTRA_ENV_SETTINGS
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"kernel_loadaddr=0x84808000\0" \
+	"fdt_loadaddr=0x85700000\0" \
+	"script=/boot/uEnv.txt\0" \
+	"loadbootscript=" \
+		"ext2load mmc 0:4 ${kernel_loadaddr} ${script};\0" \
+	"bootscript=echo Running bootscript from mmc ...; " \
+		"env import -t ${kernel_loadaddr} ${filesize};\0" \
+	"udoo_boot_init=" \
+		"if run loadbootscript; then " \
+			"run bootscript; " \
+		"fi; " \
+		"udooinit; " \
+		"ext2load mmc 0:5 ${fdt_loadaddr} ${fdt_file}; \0" \
+	"splashpos=m,m\0" \
+	"fdt_high=0xffffffff\0" \
+	"initrd_high=0xffffffff\0" \
+	"recoverycmd=run udoo_boot_init; boota mmc0 recovery\0"
+#endif
+
+#endif				/* __CONFIG_H */
diff --git a/include/configs/udoo_quad_dual.h b/include/configs/udoo_quad_dual.h
index d9deef5..c532639 100644
--- a/include/configs/udoo_quad_dual.h
+++ b/include/configs/udoo_quad_dual.h
@@ -81,7 +81,7 @@
 	"splashpos=m,m\0" \
 	"fdt_high=0xffffffff\0" \
 	"initrd_high=0xffffffff\0" \
-	"fdt_file=undefined\0" \
+	"fdt_file=autodetect\0" \
 	"fdt_addr=0x18000000\0" \
 	"boot_fdt=try\0" \
 	"ip_dyn=yes\0" \
-- 
2.7.4

