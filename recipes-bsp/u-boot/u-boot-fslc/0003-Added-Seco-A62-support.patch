From a1fcfc361ed83f0ac9328d6367fec2f31136403d Mon Sep 17 00:00:00 2001
From: Christian Ege <k4230r6@gmail.com>
Date: Fri, 30 Dec 2016 09:51:52 +0100
Subject: [PATCH 3/5] Added Seco A62 support

This adds support for the industrial UDOO variant without Arduino

Signed-off-by: Christian Ege <k4230r6@gmail.com>
Signed-off-by: Drew Moseley <drew.moseley@mender.io>
---
 arch/arm/cpu/armv7/mx6/Kconfig  |   5 +
 board/udoo/a62/Kconfig          |  15 ++
 board/udoo/a62/MAINTAINERS      |   7 +
 board/udoo/a62/Makefile         |  12 +
 board/udoo/a62/a62.c            | 519 ++++++++++++++++++++++++++++++++++++++++
 board/udoo/a62/detectboard.h    |  13 +
 board/udoo/a62/spl.c            | 320 +++++++++++++++++++++++++
 board/udoo/common/Makefile      |   2 +-
 board/udoo/common/udooinit.c    |  54 +++++
 board/udoo/common/udooinit.h    |  16 ++
 configs/udoo_a62_defconfig      |  37 +++
 drivers/watchdog/Kconfig        |   3 +
 drivers/watchdog/Makefile       |   1 +
 drivers/watchdog/apx_watchdog.c |  48 ++++
 include/configs/udoo_a62.h      | 207 ++++++++++++++++
 15 files changed, 1258 insertions(+), 1 deletion(-)
 create mode 100644 board/udoo/a62/Kconfig
 create mode 100644 board/udoo/a62/MAINTAINERS
 create mode 100644 board/udoo/a62/Makefile
 create mode 100644 board/udoo/a62/a62.c
 create mode 100644 board/udoo/a62/detectboard.h
 create mode 100644 board/udoo/a62/spl.c
 create mode 100644 board/udoo/common/udooinit.c
 create mode 100644 board/udoo/common/udooinit.h
 create mode 100644 configs/udoo_a62_defconfig
 create mode 100644 drivers/watchdog/apx_watchdog.c
 create mode 100644 include/configs/udoo_a62.h

diff --git a/arch/arm/cpu/armv7/mx6/Kconfig b/arch/arm/cpu/armv7/mx6/Kconfig
index 4b31e6d..1503b82 100644
--- a/arch/arm/cpu/armv7/mx6/Kconfig
+++ b/arch/arm/cpu/armv7/mx6/Kconfig
@@ -311,6 +311,10 @@ config TARGET_SAMTEC_VINING_2000
 	select DM
 	select DM_THERMAL
 
+config TARGET_UDOO_A62
+	bool "Seco (UDOO) A62 "
+	select SUPPORT_SPL
+
 config TARGET_WANDBOARD
 	bool "wandboard"
 	select BOARD_LATE_INIT
@@ -386,6 +390,7 @@ source "board/toradex/apalis_imx6/Kconfig"
 source "board/toradex/colibri_imx6/Kconfig"
 source "board/udoo/quad_dual/Kconfig"
 source "board/udoo/neo/Kconfig"
+source "board/udoo/a62/Kconfig"
 source "board/wandboard/Kconfig"
 source "board/warp/Kconfig"
 
diff --git a/board/udoo/a62/Kconfig b/board/udoo/a62/Kconfig
new file mode 100644
index 0000000..87a5c29
--- /dev/null
+++ b/board/udoo/a62/Kconfig
@@ -0,0 +1,15 @@
+if TARGET_UDOO_A62
+
+config SYS_BOARD
+	default "a62"
+
+config SYS_VENDOR
+	default "udoo"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "udoo_a62"
+
+endif
diff --git a/board/udoo/a62/MAINTAINERS b/board/udoo/a62/MAINTAINERS
new file mode 100644
index 0000000..f2add5a
--- /dev/null
+++ b/board/udoo/a62/MAINTAINERS
@@ -0,0 +1,7 @@
+A62 BOARD
+M:	Christian Ege <k4230r6@gmail.com>
+S:	Maintained
+F:	board/udoo/a62/
+F:	include/configs/udoo_a62.h
+F:	configs/udoo_a62_defconfig
+
diff --git a/board/udoo/a62/Makefile b/board/udoo/a62/Makefile
new file mode 100644
index 0000000..751e41c
--- /dev/null
+++ b/board/udoo/a62/Makefile
@@ -0,0 +1,12 @@
+#
+# (C) Copyright 2015 Seco
+# (C) Copyright 2016 Christian Ege
+#
+# Author: Davide Cardillo <davide.cardillo@seco.com>
+# Author: Christian Ege <k4230r6@gmail.com>
+#
+# SPDX-License-Identifier:     GPL-2.0+
+#
+
+obj-y                            := a62.o 
+obj-$(CONFIG_SPL_BUILD)  	 += spl.o 
diff --git a/board/udoo/a62/a62.c b/board/udoo/a62/a62.c
new file mode 100644
index 0000000..01b7ab6
--- /dev/null
+++ b/board/udoo/a62/a62.c
@@ -0,0 +1,519 @@
+/*
+ * Copyright (C) 2013 Freescale Semiconductor, Inc.
+ *
+ * Author: Fabio Estevam <fabio.estevam@freescale.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include "../common/udooinit.h"
+
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <malloc.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/sata.h>
+#include <asm/imx-common/spi.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/io.h>
+#include <asm/arch/sys_proto.h>
+#include <micrel.h>
+#include <miiphy.h>
+#include <netdev.h>
+#include <i2c.h>
+#include <spi_flash.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP |                   \
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS | PAD_CTL_SPEED_MED | \
+		PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL   (PAD_CTL_PUS_100K_UP |                  \
+		PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |   \
+		PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define WDT_EN		IMX_GPIO_NR(5, 4)
+#define WDT_TRG		IMX_GPIO_NR(3, 19)
+
+int dram_init(void)
+{
+	gd->ram_size = imx_ddr_size();
+
+	return 0;
+}
+
+static iomux_v3_cfg_t const uart2_pads[] = {
+	IOMUX_PADS(PAD_EIM_D26__UART2_TX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL)),
+	IOMUX_PADS(PAD_EIM_D27__UART2_RX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL)),
+};
+
+/* ON BOARD uSD	*/
+iomux_v3_cfg_t const usdhc3_pads[] = {
+	IOMUX_PADS(PAD_SD3_CLK__SD3_CLK     | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_CMD__SD3_CMD     | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_DAT0__SD3_DATA0  | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_DAT1__SD3_DATA1  | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_DAT2__SD3_DATA2  | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_DAT3__SD3_DATA3  | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_DAT5__GPIO7_IO00 | MUX_PAD_CTRL(NO_PAD_CTRL)),     // CD
+	IOMUX_PADS(PAD_NANDF_D5__GPIO2_IO05 | MUX_PAD_CTRL(NO_PAD_CTRL)),     // PWR
+};
+
+/* eMMC */
+iomux_v3_cfg_t const usdhc4_pads[] = {
+	IOMUX_PADS(PAD_SD4_CLK__SD4_CLK     | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_CMD__SD4_CMD     | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_DAT0__SD4_DATA0  | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_DAT1__SD4_DATA1  | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_DAT2__SD4_DATA2  | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_DAT3__SD4_DATA3  | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_DAT4__SD4_DATA4  | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_DAT5__SD4_DATA5  | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_DAT6__SD4_DATA6  | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_DAT7__SD4_DATA7  | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+};
+
+static iomux_v3_cfg_t const wdog_pads[] = {
+	IOMUX_PADS(PAD_EIM_A24__GPIO5_IO04 | MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_EIM_D19__GPIO3_IO19),
+};
+
+static iomux_v3_cfg_t const ecspi1_pads[] = {
+	IOMUX_PADS(PAD_EIM_D17__ECSPI1_MISO  | MUX_PAD_CTRL(SPI_PAD_CTRL)),
+	IOMUX_PADS(PAD_EIM_D18__ECSPI1_MOSI  | MUX_PAD_CTRL(SPI_PAD_CTRL)),
+	IOMUX_PADS(PAD_EIM_D16__ECSPI1_SCLK  | MUX_PAD_CTRL(SPI_PAD_CTRL)),
+	IOMUX_PADS(PAD_EIM_EB2__GPIO2_IO30   | MUX_PAD_CTRL(NO_PAD_CTRL)),
+};
+
+/*  I2C2 - EEPROM, HDMI  */
+struct i2c_pads_info i2c_pad_info1 = {
+	.scl = {
+		.i2c_mode  = MX6Q_PAD_KEY_COL3__I2C2_SCL   | MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6Q_PAD_KEY_COL3__GPIO4_IO12 | MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp        = IMX_GPIO_NR(4, 12),
+	},
+	.sda = {
+		.i2c_mode  = MX6Q_PAD_KEY_ROW3__I2C2_SDA   | MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6Q_PAD_KEY_ROW3__GPIO4_IO13 | MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp        = IMX_GPIO_NR(4, 13),
+	},
+};
+
+
+/*  I2C3 - H29, CN11  */
+struct i2c_pads_info i2c_pad_info2 = {
+	.scl = {
+		.i2c_mode  = MX6Q_PAD_GPIO_5__I2C3_SCL
+				| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6Q_PAD_GPIO_5__GPIO1_IO05
+				| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp        = IMX_GPIO_NR(1, 5),
+	},
+	.sda = {
+		.i2c_mode  = MX6Q_PAD_GPIO_6__I2C3_SDA
+				| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6Q_PAD_GPIO_6__GPIO1_IO06
+				| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp        = IMX_GPIO_NR(7, 11),
+	},
+};
+int mx6_rgmii_rework(struct phy_device *phydev)
+{
+	/*
+	 * Bug: Apparently uDoo does not works with Gigabit switches...
+	 * Limiting speed to 10/100Mbps, and setting master mode, seems to
+	 * be the only way to have a successfull PHY auto negotiation.
+	 * How to fix: Understand why Linux kernel do not have this issue.
+	 */
+	phy_write(phydev, MDIO_DEVAD_NONE, MII_CTRL1000, 0x1c00);
+
+	/* control data pad skew - devaddr = 0x02, register = 0x04 */
+	ksz9031_phy_extended_write(phydev, 0x02,
+				   MII_KSZ9031_EXT_RGMII_CTRL_SIG_SKEW,
+				   MII_KSZ9031_MOD_DATA_NO_POST_INC, 0x0000);
+	/* rx data pad skew - devaddr = 0x02, register = 0x05 */
+	ksz9031_phy_extended_write(phydev, 0x02,
+				   MII_KSZ9031_EXT_RGMII_RX_DATA_SKEW,
+				   MII_KSZ9031_MOD_DATA_NO_POST_INC, 0x0000);
+	/* tx data pad skew - devaddr = 0x02, register = 0x05 */
+	ksz9031_phy_extended_write(phydev, 0x02,
+				   MII_KSZ9031_EXT_RGMII_TX_DATA_SKEW,
+				   MII_KSZ9031_MOD_DATA_NO_POST_INC, 0x0000);
+	/* gtx and rx clock pad skew - devaddr = 0x02, register = 0x08 */
+	ksz9031_phy_extended_write(phydev, 0x02,
+				   MII_KSZ9031_EXT_RGMII_CLOCK_SKEW,
+				   MII_KSZ9031_MOD_DATA_NO_POST_INC, 0x03FF);
+	return 0;
+}
+
+static iomux_v3_cfg_t const enet_pads1[] = {
+	IOMUX_PADS(PAD_ENET_MDIO__ENET_MDIO		| MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_ENET_MDC__ENET_MDC		| MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_TXC__RGMII_TXC	| MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_TD0__RGMII_TD0	| MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_TD1__RGMII_TD1	| MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_TD2__RGMII_TD2	| MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_TD3__RGMII_TD3	| MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_TX_CTL__RGMII_TX_CTL	| MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_ENET_REF_CLK__ENET_TX_CLK	| MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_RXC__RGMII_RXC	| MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	/* RGMII reset */
+	IOMUX_PADS(PAD_EIM_D23__GPIO3_IO23		| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	/* Ethernet power supply */
+	IOMUX_PADS(PAD_KEY_COL2__GPIO4_IO10		| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	/* pin 32 - 1 - (MODE0) all */
+	IOMUX_PADS(PAD_RGMII_RD0__GPIO6_IO25		| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	/* pin 31 - 1 - (MODE1) all */
+	IOMUX_PADS(PAD_RGMII_RD1__GPIO6_IO27		| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	/* pin 28 - 1 - (MODE2) all */
+	IOMUX_PADS(PAD_RGMII_RD2__GPIO6_IO28		| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	/* pin 27 - 1 - (MODE3) all */
+	IOMUX_PADS(PAD_RGMII_RD3__GPIO6_IO29		| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	/* pin 33 - 1 - (CLK125_EN) 125Mhz clockout enabled */
+	IOMUX_PADS(PAD_RGMII_RX_CTL__GPIO6_IO24	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+};
+
+static iomux_v3_cfg_t const enet_pads2[] = {
+	IOMUX_PADS(PAD_RGMII_RD0__RGMII_RD0	| MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_RD1__RGMII_RD1	| MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_RD2__RGMII_RD2	| MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_RD3__RGMII_RD3	| MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_RX_CTL__RGMII_RX_CTL	| MUX_PAD_CTRL(ENET_PAD_CTRL)),
+};
+
+static void setup_a62_i2c(void)
+{
+	setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+	setup_i2c(2, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info2);
+
+}
+
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+		return (bus == 0 && cs == 0) ? (IMX_GPIO_NR(2, 30)) : -1;
+}
+
+static void setup_spinor(void)
+{
+	gpio_request(IMX_GPIO_NR(2, 30), "spi_cs");
+	gpio_direction_output(IMX_GPIO_NR(2, 30), 1);
+	imx_iomux_v3_setup_multiple_pads(ecspi1_pads, ARRAY_SIZE(ecspi1_pads));
+}
+
+static void setup_iomux_enet(void)
+{
+	SETUP_IOMUX_PADS(enet_pads1);
+	udelay(20);
+	gpio_direction_output(IMX_GPIO_NR(4, 10), 1); /* Power supply on */
+	gpio_set_value (IMX_GPIO_NR(4, 10), 1);
+
+	gpio_direction_output(IMX_GPIO_NR(3, 23), 0); /* assert PHY rst */
+
+	gpio_direction_output(IMX_GPIO_NR(6, 24), 1);
+	gpio_direction_output(IMX_GPIO_NR(6, 25), 1);
+	gpio_direction_output(IMX_GPIO_NR(6, 27), 1);
+	gpio_direction_output(IMX_GPIO_NR(6, 28), 1);
+	gpio_direction_output(IMX_GPIO_NR(6, 29), 1);
+	udelay(1000);
+
+	gpio_set_value(IMX_GPIO_NR(3, 23), 1); /* deassert PHY rst */
+
+	/* Need 100ms delay to exit from reset. */
+	udelay(1000 * 100);
+
+	gpio_free(IMX_GPIO_NR(6, 24));
+	gpio_free(IMX_GPIO_NR(6, 25));
+	gpio_free(IMX_GPIO_NR(6, 27));
+	gpio_free(IMX_GPIO_NR(6, 28));
+	gpio_free(IMX_GPIO_NR(6, 29));
+
+	SETUP_IOMUX_PADS(enet_pads2);
+}
+
+static void setup_iomux_uart(void)
+{
+	SETUP_IOMUX_PADS(uart2_pads);
+}
+
+static void setup_iomux_wdog(void)
+{
+	SETUP_IOMUX_PADS(wdog_pads);
+	gpio_direction_output(WDT_TRG, 0);
+	gpio_direction_output(WDT_EN, 1);
+	gpio_direction_input(WDT_TRG);
+}
+
+/*  __________________________________________________________________________
+ * |                                                                          |
+ * |                                   USDHC                                  |
+ * |__________________________________________________________________________|
+ */
+#ifdef CONFIG_FSL_ESDHC
+
+#define USDHC3_CD_GPIO	IMX_GPIO_NR(7, 0)
+#define USDHC3_PWR_GPIO IMX_GPIO_NR(2, 5)
+
+/* USDHC map:
+ * 	USDHC4  -->  eMMC  -->  FSL_SDHC: 0
+ * 	USDHC3  -->  uSD   -->  FSL_SDHC: 1
+ */
+
+struct fsl_esdhc_cfg usdhc_cfg[CONFIG_SYS_FSL_USDHC_NUM] = {
+	{USDHC3_BASE_ADDR, 0, 4}, // FSL_SDHC: 0, uSD the primary boot medium when J27 is closed
+	{USDHC4_BASE_ADDR, 0, 8}, // FSL_SDHC: 1, eMMC (optional) the secondary boot medium when J27 is open
+};
+
+enum mxc_clock usdhc_clk[CONFIG_SYS_FSL_USDHC_NUM] = {
+	MXC_ESDHC4_CLK,
+	MXC_ESDHC3_CLK,
+};
+
+/* map the usdhc controller id to the devno given to the board device */
+int usdhc_devno[4] = { -1, -1, 1, 0};
+
+int board_mmc_getcd (struct mmc *mmc) {
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+		case USDHC3_BASE_ADDR:
+			ret = !gpio_get_value(USDHC3_CD_GPIO);
+			break;
+		case USDHC4_BASE_ADDR:
+			ret = 1; /* eMMC/uSDHC4 is always present */
+			break;
+	}
+
+	return ret;
+}
+
+int check_mmc_autodetect (void) {
+	char *autodetect_str = getenv ("mmcautodetect");
+
+	if ( (autodetect_str != NULL) &&
+		(strcmp(autodetect_str, "yes") == 0) ) {
+		return 1;
+	}
+
+	return 0;
+}
+
+int check_emmc_selected(void) {
+
+	struct src *psrc = (struct src *)SRC_BASE_ADDR;
+	unsigned int reg_smbr1 = readl(&psrc->sbmr1);
+	unsigned int reg = readl(&psrc->sbmr1) >> 11;
+	unsigned int port = reg & 0x3;
+	int ret = 0;
+	if ((reg_smbr1 & 0x0820) == 0x0820)
+	{
+		ret = 1;
+		printf("[SPL] Selected eMMC as boot medium; port %u \n", port);
+	}
+	else
+	{
+		printf("[SPL] Selected uSD as boot medium; port %u \n", port);
+	}
+	return ret;
+}
+
+int board_mmc_init(bd_t *bis){
+#ifndef CONFIG_SPL_BUILD
+	int ret;
+	int i;
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+			SETUP_IOMUX_PADS(usdhc4_pads);
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC4_CLK);
+			break;
+		case 1:
+			SETUP_IOMUX_PADS(usdhc3_pads);
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+			gpio_direction_input(USDHC3_CD_GPIO);
+			gpio_direction_output(USDHC3_PWR_GPIO, 1);
+			break;
+
+		default:
+			printf("Warning: you configured more USDHC controllers"
+			       "(%d) then supported by the board (%d)\n",
+			       i + 1, CONFIG_SYS_FSL_USDHC_NUM);
+			return -EINVAL;
+		}
+
+		ret = fsl_esdhc_initialize(bis, &usdhc_cfg[i]);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+#else
+
+	if (check_emmc_selected()) {
+	   /* Setup eMMC */
+	   SETUP_IOMUX_PADS(usdhc4_pads);
+	   usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC4_CLK);
+	   return fsl_esdhc_initialize(bis, &usdhc_cfg[0]);
+	} else {
+	   /* Setup uSD */
+	   SETUP_IOMUX_PADS(usdhc3_pads);
+	   usdhc_cfg[1].esdhc_base = USDHC3_BASE_ADDR;
+	   usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+	   gpio_direction_input(USDHC3_CD_GPIO);
+	   gpio_direction_output(USDHC3_PWR_GPIO, 1);
+	   gd->arch.sdhc_clk = usdhc_cfg[1].sdhc_clk;
+	   return fsl_esdhc_initialize(bis, &usdhc_cfg[1]);
+	}
+#endif
+}
+#endif /*  CONFIG_FSL_ESDHC  */
+
+int board_eth_init(bd_t *bis)
+{
+	uint32_t base = IMX_FEC_BASE;
+	struct mii_dev *bus = NULL;
+	struct phy_device *phydev = NULL;
+	int ret;
+
+	setup_iomux_enet();
+
+#ifdef CONFIG_FEC_MXC
+	bus = fec_get_miibus(base, -1);
+	if (!bus)
+		return -EINVAL;
+	/* scan phy 4,5,6,7 */
+	phydev = phy_find_by_mask(bus, (0xf << 4), PHY_INTERFACE_MODE_RGMII);
+
+	if (!phydev) {
+		ret = -EINVAL;
+		goto free_bus;
+	}
+	printf("using phy at %d\n", phydev->addr);
+	ret  = fec_probe(bis, -1, base, bus, phydev);
+	if (ret)
+		goto free_phydev;
+#endif
+	return 0;
+
+free_phydev:
+	free(phydev);
+free_bus:
+	free(bus);
+	return ret;
+}
+
+int board_early_init_f(void)
+{
+	setup_iomux_wdog();
+	setup_iomux_uart();
+
+	return 0;
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+	mx6_rgmii_rework(phydev);
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+
+int board_init(void)
+{
+	/* address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+/*
+#ifdef CONFIG_CMD_I2C
+	setup_a62_i2c();
+#endif
+#ifdef CONFIG_CMD_SF
+	setup_spinor();
+#endif
+#ifdef CONFIG_CMD_SATA
+	if (is_cpu_type(MXC_CPU_MX6Q))
+		setup_sata();
+#endif
+*/
+	return 0;
+}
+
+int board_late_init(void)
+{
+#ifdef CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+	if (is_cpu_type(MXC_CPU_MX6Q))
+		setenv("board_rev", "MX6Q");
+	else if (is_cpu_type(MXC_CPU_MX6DL))
+		setenv("board_rev", "MX6DL");
+	else
+		setenv("board_rev", "MX6SOLO");
+#endif
+
+	if (check_emmc_selected())
+	{ /* Boot from eMMC */
+		printf("Booting from eMMC!\n");
+		setenv("mmcdev","1");
+		setenv("mmcroot","/dev/mmcblk1p1 rootwait rw");
+	}
+
+
+	return 0;
+}
+
+int checkboard(void)
+{
+	if (is_cpu_type(MXC_CPU_MX6Q))
+		puts("Board: Seco SBC-A62-J-QUAD\n");
+	else if (is_cpu_type(MXC_CPU_MX6DL))
+		 puts("Board: Seco SBC-A62-J-LITE\n");
+	else
+		puts("Board: Seco SBC-A62-J-SOLO\n");
+
+	return 0;
+}
+
+/**
+ * After loading uEnv.txt, we autodetect which fdt file we need to load.
+ * uEnv.txt can contain:
+ *  - video_output=hdmi|lvds7|lvds15
+ *    any other value (or if the variable is not specified) will default to "hdmi"
+ *  - use_custom_dtb=true|false
+ *    any other value (or if the variable is not specified) will default to "false"
+ *
+ * Despite the signature, this command does not accept any argument.
+ */
+int do_udooinit(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	char* modelfdt;
+
+	if (is_cpu_type(MXC_CPU_MX6Q)) {
+		modelfdt = "imx6q-seco_A62";
+	} else {
+		modelfdt = "imx6dl-seco_A62";
+	}
+
+	return udooinit_setenv(modelfdt);
+}
+
+U_BOOT_CMD(
+	udooinit,	1,	1,	do_udooinit,
+	"(UDOO) determine the device tree to load", ""
+);
diff --git a/board/udoo/a62/detectboard.h b/board/udoo/a62/detectboard.h
new file mode 100644
index 0000000..dbf0ea9
--- /dev/null
+++ b/board/udoo/a62/detectboard.h
@@ -0,0 +1,13 @@
+/*
+ * Copyright (C) UDOO Team
+ *
+ * Author: Francesco Montefoschi <francesco.monte@gmail.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#define  SYS_DDR_SIZE_2x256   512
+#define  SYS_DDR_SIZE_4x256   1024
+#define  SYS_DDR_SIZE_4x512   2048
+
+
diff --git a/board/udoo/a62/spl.c b/board/udoo/a62/spl.c
new file mode 100644
index 0000000..193d893
--- /dev/null
+++ b/board/udoo/a62/spl.c
@@ -0,0 +1,320 @@
+/*
+ * Copyright (C) UDOO Team
+ * Copyright (C) 2016 Christian Ege
+ *
+ * Author: Francesco Montefoschi <francesco.monte@gmail.com>
+ * Author: Christian Ege <k4230r6@gmail.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/video.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/io.h>
+#include <asm/arch/sys_proto.h>
+#include <spl.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#if defined(CONFIG_SPL_BUILD)
+#include <asm/arch/mx6-ddr.h>
+
+#ifdef CONFIG_APX_WATCHDOG
+#include <watchdog.h>
+#endif
+
+/*
+ * Driving strength:
+ *   0x30 == 40 Ohm
+ *   0x28 == 48 Ohm
+ */
+#define IMX6DQ_DRIVE_STRENGTH	0x30
+#define IMX6SDL_DRIVE_STRENGTH	0x28
+
+/* configure MX6Q/DUAL mmdc DDR io registers */
+static struct mx6dq_iomux_ddr_regs mx6dq_ddr_ioregs = {
+	.dram_sdclk_0 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_sdclk_1 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_cas = IMX6DQ_DRIVE_STRENGTH,
+	.dram_ras = IMX6DQ_DRIVE_STRENGTH,
+	.dram_reset = IMX6DQ_DRIVE_STRENGTH,
+	.dram_sdcke0 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_sdcke1 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_sdba2 = 0x00000000,
+	.dram_sdodt0 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_sdodt1 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_sdqs0 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_sdqs1 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_sdqs2 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_sdqs3 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_sdqs4 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_sdqs5 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_sdqs6 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_sdqs7 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_dqm0 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_dqm1 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_dqm2 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_dqm3 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_dqm4 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_dqm5 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_dqm6 = IMX6DQ_DRIVE_STRENGTH,
+	.dram_dqm7 = IMX6DQ_DRIVE_STRENGTH,
+};
+
+/* configure MX6Q/DUAL mmdc GRP io registers */
+static struct mx6dq_iomux_grp_regs mx6dq_grp_ioregs = {
+	.grp_ddr_type = 0x000c0000,
+	.grp_ddrmode_ctl = 0x00020000,
+	.grp_ddrpke = 0x00000000,
+	.grp_addds = IMX6DQ_DRIVE_STRENGTH,
+	.grp_ctlds = IMX6DQ_DRIVE_STRENGTH,
+	.grp_ddrmode = 0x00020000,
+	.grp_b0ds = IMX6DQ_DRIVE_STRENGTH,
+	.grp_b1ds = IMX6DQ_DRIVE_STRENGTH,
+	.grp_b2ds = IMX6DQ_DRIVE_STRENGTH,
+	.grp_b3ds = IMX6DQ_DRIVE_STRENGTH,
+	.grp_b4ds = IMX6DQ_DRIVE_STRENGTH,
+	.grp_b5ds = IMX6DQ_DRIVE_STRENGTH,
+	.grp_b6ds = IMX6DQ_DRIVE_STRENGTH,
+	.grp_b7ds = IMX6DQ_DRIVE_STRENGTH,
+};
+
+/* configure MX6SOLO/DUALLITE mmdc DDR io registers */
+struct mx6sdl_iomux_ddr_regs mx6sdl_ddr_ioregs = {
+	.dram_sdclk_0 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_sdclk_1 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_cas = IMX6SDL_DRIVE_STRENGTH,
+	.dram_ras = IMX6SDL_DRIVE_STRENGTH,
+	.dram_reset = IMX6SDL_DRIVE_STRENGTH,
+	.dram_sdcke0 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_sdcke1 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_sdba2 = 0x00000000,
+	.dram_sdodt0 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_sdodt1 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_sdqs0 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_sdqs1 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_sdqs2 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_sdqs3 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_sdqs4 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_sdqs5 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_sdqs6 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_sdqs7 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_dqm0 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_dqm1 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_dqm2 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_dqm3 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_dqm4 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_dqm5 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_dqm6 = IMX6SDL_DRIVE_STRENGTH,
+	.dram_dqm7 = IMX6SDL_DRIVE_STRENGTH,
+};
+
+/* configure MX6SOLO/DUALLITE mmdc GRP io registers */
+struct mx6sdl_iomux_grp_regs mx6sdl_grp_ioregs = {
+	.grp_ddr_type = 0x000c0000,
+	.grp_ddrmode_ctl = 0x00020000,
+	.grp_ddrpke = 0x00000000,
+	.grp_addds = IMX6SDL_DRIVE_STRENGTH,
+	.grp_ctlds = IMX6SDL_DRIVE_STRENGTH,
+	.grp_ddrmode = 0x00020000,
+	.grp_b0ds = IMX6SDL_DRIVE_STRENGTH,
+	.grp_b1ds = IMX6SDL_DRIVE_STRENGTH,
+	.grp_b2ds = IMX6SDL_DRIVE_STRENGTH,
+	.grp_b3ds = IMX6SDL_DRIVE_STRENGTH,
+	.grp_b4ds = IMX6SDL_DRIVE_STRENGTH,
+	.grp_b5ds = IMX6SDL_DRIVE_STRENGTH,
+	.grp_b6ds = IMX6SDL_DRIVE_STRENGTH,
+	.grp_b7ds = IMX6SDL_DRIVE_STRENGTH,
+};
+
+/* MT41K128M16JT-125 */
+static struct mx6_ddr3_cfg mt41k128m16jt_125 = {
+	/* quad = 1066, duallite = 800 */
+	.mem_speed = 1066,
+	.density = 2,
+	.width = 16,
+	.banks = 8,
+	.rowaddr = 14,
+	.coladdr = 10,
+	.pagesz = 2,
+	.trcd = 1375,
+	.trcmin = 4875,
+	.trasmin = 3500,
+	.SRT = 0,
+};
+
+static struct mx6_mmdc_calibration mx6q_1g_mmdc_calib = {
+	.p0_mpwldectrl0 = 0x00350035,
+	.p0_mpwldectrl1 = 0x001F001F,
+	.p1_mpwldectrl0 = 0x00010001,
+	.p1_mpwldectrl1 = 0x00010001,
+	.p0_mpdgctrl0 = 0x43510360,
+	.p0_mpdgctrl1 = 0x0342033F,
+	.p1_mpdgctrl0 = 0x033F033F,
+	.p1_mpdgctrl1 = 0x03290266,
+	.p0_mprddlctl = 0x4B3E4141,
+	.p1_mprddlctl = 0x47413B4A,
+	.p0_mpwrdlctl = 0x42404843,
+	.p1_mpwrdlctl = 0x4C3F4C45,
+};
+
+static struct mx6_mmdc_calibration mx6dl_1g_mmdc_calib = {
+	.p0_mpwldectrl0 = 0x002F0038,
+	.p0_mpwldectrl1 = 0x001F001F,
+	.p1_mpwldectrl0 = 0x001F001F,
+	.p1_mpwldectrl1 = 0x001F001F,
+	.p0_mpdgctrl0 = 0x425C0251,
+	.p0_mpdgctrl1 = 0x021B021E,
+	.p1_mpdgctrl0 = 0x021B021E,
+	.p1_mpdgctrl1 = 0x01730200,
+	.p0_mprddlctl = 0x45474C45,
+	.p1_mprddlctl = 0x44464744,
+	.p0_mpwrdlctl = 0x3F3F3336,
+	.p1_mpwrdlctl = 0x32383630,
+};
+
+static struct mx6_mmdc_calibration mx6s_128x32_mmdc_calib = {
+	.p0_mpwldectrl0 = 0x002F0038,
+	.p0_mpwldectrl1 = 0x001F001F,
+	.p1_mpwldectrl0 = 0x001F001F,
+	.p1_mpwldectrl1 = 0x001F001F,
+	.p0_mpdgctrl0 = 0x425C0251,
+	.p0_mpdgctrl1 = 0x021B021E,
+	.p1_mpdgctrl0 = 0x021B021E,
+	.p1_mpdgctrl1 = 0x01730200,
+	.p0_mprddlctl = 0x45474C45,
+	.p1_mprddlctl = 0x44464744,
+	.p0_mpwrdlctl = 0x3F3F3336,
+	.p1_mpwrdlctl = 0x32383630,
+};
+
+static void ccgr_init(void)
+{
+	struct mxc_ccm_reg *ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	/* set the default clock gate to save power */
+	writel(0x00C03F3F, &ccm->CCGR0);
+	writel(0x0030FC03, &ccm->CCGR1);
+	writel(0x0FFFC000, &ccm->CCGR2);
+	writel(0x3FF00000, &ccm->CCGR3);
+	writel(0x00FFF300, &ccm->CCGR4);
+	writel(0x0F0000C3, &ccm->CCGR5);
+	writel(0x000003FF, &ccm->CCGR6);
+	/* Enable USB HUB Clock on A62 Board */
+	writel(0x010E0000, &ccm->ccosr);
+
+}
+
+static void gpr_init(void)
+{
+	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
+
+	/* enable AXI cache for VDOA/VPU/IPU */
+	writel(0xF00000FF, &iomux->gpr[4]);
+	/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+	writel(0x007F007F, &iomux->gpr[6]);
+	writel(0x007F007F, &iomux->gpr[7]);
+}
+
+static void spl_dram_init(void)
+{
+	struct mx6_ddr_sysinfo sysinfo = {
+		/* width of data bus:0=16,1=32,2=64 */
+		.dsize = 2,
+		/* config for full 4GB range so that get_mem_size() works */
+		.cs_density = 32, /* 32Gb per CS */
+		/* single chip select */
+		.ncs = 1,
+		.cs1_mirror = 0,
+		.rtt_wr = 1 /*DDR3_RTT_60_OHM*/,	/* RTT_Wr = RZQ/4 */
+		.rtt_nom = 1 /*DDR3_RTT_60_OHM*/,	/* RTT_Nom = RZQ/4 */
+		.walat = 1,	/* Write additional latency */
+		.ralat = 5,	/* Read additional latency */
+		.mif3_mode = 3,	/* Command prediction working mode */
+		.bi_on = 1,	/* Bank interleaving enabled */
+		.sde_to_rst = 0x10,	/* 14 cycles, 200us (JEDEC default) */
+		.rst_to_cke = 0x23,	/* 33 cycles, 500us (JEDEC default) */
+	};
+
+	if (is_cpu_type(MXC_CPU_MX6SOLO)) {
+		mt41k128m16jt_125.mem_speed = 1066;
+		sysinfo.dsize = 1,
+		sysinfo.rtt_nom = 1;
+		sysinfo.rtt_wr = 1;
+
+		mx6sdl_dram_iocfg(32, &mx6sdl_ddr_ioregs, &mx6sdl_grp_ioregs);
+		mx6_dram_cfg(&sysinfo, &mx6s_128x32_mmdc_calib, &mt41k128m16jt_125);
+	} else if (is_cpu_type(MXC_CPU_MX6DL)) {
+		mt41k128m16jt_125.mem_speed = 800;
+		sysinfo.rtt_nom = 1;
+		sysinfo.rtt_wr = 1;
+
+		mx6sdl_dram_iocfg(64, &mx6sdl_ddr_ioregs, &mx6sdl_grp_ioregs);
+		mx6_dram_cfg(&sysinfo, &mx6dl_1g_mmdc_calib, &mt41k128m16jt_125);
+	} else if (is_cpu_type(MXC_CPU_MX6Q)) {
+		mt41k128m16jt_125.mem_speed = 1066;
+		sysinfo.rtt_nom = 2;
+		sysinfo.rtt_wr = 2;
+
+		mx6dq_dram_iocfg(64, &mx6dq_ddr_ioregs, &mx6dq_grp_ioregs);
+		mx6_dram_cfg(&sysinfo, &mx6q_1g_mmdc_calib, &mt41k128m16jt_125);
+	}
+
+	udelay(100);
+}
+
+
+#ifdef CONFIG_APX_WATCHDOG
+static void init_func_watchdog_init(void)
+{
+	hw_watchdog_init();
+	WATCHDOG_RESET();
+}
+#endif /* CONFIG_APX_WATCHDOG */
+
+void board_init_f(ulong dummy)
+{
+	ccgr_init();
+
+	/* setup AIPS and disable watchdog */
+	arch_cpu_init();
+
+	gpr_init();
+
+	/* iomux and setup of i2c */
+	board_early_init_f();
+
+	/* setup GP timer */
+	timer_init();
+
+	/* Seco APX watchdog Init*/
+#ifdef CONFIG_APX_WATCHDOG
+	init_func_watchdog_init();
+#endif
+
+	/* UART clocks enabled and gd valid - init serial console */
+	preloader_console_init();
+
+	/* DDR initialization */
+	spl_dram_init();
+
+	/* Clear the BSS. */
+	memset(__bss_start, 0, __bss_end - __bss_start);
+
+#ifdef CONFIG_APX_WATCHDOG
+	WATCHDOG_RESET();
+#endif
+
+	/* load/boot image from boot device */
+	board_init_r(NULL, 0);
+}
+#endif /* CONFIG_SPL_BUILD */
diff --git a/board/udoo/common/Makefile b/board/udoo/common/Makefile
index 0729cb8..09af343 100644
--- a/board/udoo/common/Makefile
+++ b/board/udoo/common/Makefile
@@ -4,4 +4,4 @@
 #
 
 obj- := __dummy__.o
-obj-y  := trim.o
+obj-y  := trim.o udooinit.o
diff --git a/board/udoo/common/udooinit.c b/board/udoo/common/udooinit.c
new file mode 100644
index 0000000..5098bee
--- /dev/null
+++ b/board/udoo/common/udooinit.c
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) UDOO Team
+ *
+ * Author: Christian Ege <k4230r6@gmail.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include "udooinit.h"
+#include <common.h>
+
+/**
+ * helper function to set the set fdt_file name
+ */
+int udooinit_setenv(const char* modelfdt)
+{
+	char* video_part = "-hdmi";
+	char* video = getenv("video_output");
+
+	if (video) {
+		video = trim(video);
+		if (strcmp(video, "lvds7") == 0) {
+			video_part = "-lvds7";
+		} else if (strcmp(video, "lvds15") == 0) {
+			video_part = "-lvds15";
+		}
+	}
+
+	char* actual_fdt = getenv("fdt_file");
+	if (actual_fdt) {
+		actual_fdt = trim(actual_fdt);
+		if (strcmp(actual_fdt, "autodetect") != 0) {
+			// if fdt_file is already set, do not overwrite it!
+			return 0;
+		}
+	}
+
+	char fdt_file[100];
+	char* customdtb = getenv("use_custom_dtb");
+	sprintf(fdt_file, "/boot/%s%s.dtb", modelfdt, video_part);
+	if (customdtb) {
+		customdtb = trim(customdtb);
+		if (strcmp(customdtb, "true") == 0 || strcmp(customdtb, "yes") == 0 || strcmp(customdtb, "enabled") == 0) {
+			char* dir_part = "dts-overlay";
+			sprintf(fdt_file, "/boot/%s/%s%s.dtb", dir_part, modelfdt, video_part);
+		}
+	}
+
+	printf("Device Tree: %s\n", fdt_file);
+	setenv("fdt_file", fdt_file);
+
+	return 0;
+}
+
diff --git a/board/udoo/common/udooinit.h b/board/udoo/common/udooinit.h
new file mode 100644
index 0000000..47c099e
--- /dev/null
+++ b/board/udoo/common/udooinit.h
@@ -0,0 +1,16 @@
+/*
+ * Copyright (C) UDOO Team
+ *
+ * Author: Christian Ege <k4230r6@gmail.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include "trim.h"
+
+#ifndef UDOO_INIT_H__
+#define UDOO_INIT_H__
+
+int udooinit_setenv(const char* modelfdt);
+
+#endif
diff --git a/configs/udoo_a62_defconfig b/configs/udoo_a62_defconfig
new file mode 100644
index 0000000..1b35fc9
--- /dev/null
+++ b/configs/udoo_a62_defconfig
@@ -0,0 +1,37 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_UDOO_A62=y
+CONFIG_SPL_GPIO_SUPPORT=y
+CONFIG_SPL_LIBCOMMON_SUPPORT=y
+CONFIG_SPL_LIBGENERIC_SUPPORT=y
+CONFIG_SPL_EXT_SUPPORT=y
+CONFIG_SPL_I2C_SUPPORT=y
+CONFIG_SPL_LIBDISK_SUPPORT=y
+CONFIG_SPL_MMC_SUPPORT=y
+CONFIG_SPL_SERIAL_SUPPORT=y
+CONFIG_SPL_WATCHDOG_SUPPORT=y
+CONFIG_SPL_APX_WATCHDOG=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=arch/arm/imx-common/spl_sd.cfg,MX6QDL"
+CONFIG_BOOTDELAY=3
+CONFIG_SPL=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_DM=y
+CONFIG_DM_THERMAL=y
+CONFIG_OF_LIBFDT=y
+CONFIG_SPI_FLASH=y
+CONFIG_APX_WATCHDOG=y
+CONFIG_MXC_SPI_CSHOLD=y
diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
index e69de29..513920a 100644
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -0,0 +1,3 @@
+config APX_WATCHDOG
+        bool "Support watchdog APX drivers"
+
diff --git a/drivers/watchdog/Makefile b/drivers/watchdog/Makefile
index a007ae8..c36a24d 100644
--- a/drivers/watchdog/Makefile
+++ b/drivers/watchdog/Makefile
@@ -15,3 +15,4 @@ obj-$(CONFIG_XILINX_TB_WATCHDOG) += xilinx_tb_wdt.o
 obj-$(CONFIG_BFIN_WATCHDOG)  += bfin_wdt.o
 obj-$(CONFIG_OMAP_WATCHDOG) += omap_wdt.o
 obj-$(CONFIG_DESIGNWARE_WATCHDOG) += designware_wdt.o
+obj-$(CONFIG_APX_WATCHDOG) += apx_watchdog.o
diff --git a/drivers/watchdog/apx_watchdog.c b/drivers/watchdog/apx_watchdog.c
new file mode 100644
index 0000000..909e908
--- /dev/null
+++ b/drivers/watchdog/apx_watchdog.c
@@ -0,0 +1,48 @@
+/*
+ * apx_watchdog.c - driver for i.MX6 a66 Apx Watchdog
+ *
+ * Licensed under the GPL-2 or later.
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <watchdog.h>
+#include <asm/arch/imx-regs.h>
+
+#ifdef CONFIG_APX_WATCHDOG
+
+#define WDT_IOMUX_REG(x)        ((x))
+#define WDT_PADCTRL_REG(x)      ((x))
+#define WDT_GDIR_REG(x)         ((x) + 0x4) 
+#define WDT_DR_REG(x)           ((x))
+
+ 
+#define WDT_PAD_MUX_GPIO(x)     writel(readl(WDT_IOMUX_REG((x))) | 0x5, WDT_IOMUX_REG((x)))
+
+#define WDT_PAD_CTRL_GPIO(x)    writel(0x06028, WDT_PADCTRL_REG((x)))
+
+#define WDT_DIR_OUT_GPIO(x,n)   writel(readl(WDT_GDIR_REG((x))) | ( 1 << (n)), WDT_GDIR_REG((x)))
+
+#define WDT_SET_H_GPIO(x,n)     writel(readl(WDT_DR_REG((x))) | (1 << (n)) , WDT_DR_REG((x)))
+
+#define WDT_SET_L_GPIO(x,n)     writel(readl(WDT_DR_REG((x))) & ~(1 << (n)) , WDT_DR_REG((x)))
+
+
+void hw_watchdog_reset(void)
+{
+	//APX Watchdog - Refresh watchdog 
+
+   	WDT_DIR_OUT_GPIO(APX_WDT_TRIGGER_BASE, APX_WDT_TRIGGER_NUM);
+	WDT_SET_H_GPIO(APX_WDT_TRIGGER_BASE, APX_WDT_TRIGGER_NUM);
+	WDT_SET_L_GPIO(APX_WDT_TRIGGER_BASE, APX_WDT_TRIGGER_NUM);
+}
+
+void hw_watchdog_init(void)
+{
+   	WDT_DIR_OUT_GPIO(APX_WDT_TRIGGER_BASE, APX_WDT_TRIGGER_NUM);
+	WDT_DIR_OUT_GPIO(APX_WDT_ENABLE_BASE, APX_WDT_ENABLE_NUM);
+
+	WDT_SET_L_GPIO(APX_WDT_TRIGGER_BASE, APX_WDT_TRIGGER_NUM);
+}
+#endif
+
diff --git a/include/configs/udoo_a62.h b/include/configs/udoo_a62.h
new file mode 100644
index 0000000..1270989
--- /dev/null
+++ b/include/configs/udoo_a62.h
@@ -0,0 +1,207 @@
+/*
+ * Copyright (C) 2013 Freescale Semiconductor, Inc
+ * Copyright (C) 2015 Seco
+ * Copyright (C) 2016 Christian Ege
+ *
+ * Author: Christian Ege <k4230r6@gmail.com>
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+
+#define CONFIG_SPL_ENV_SUPPORT
+#include "imx6_spl.h"
+
+
+#define MACH_TYPE_SECOA62	4800
+#define CONFIG_MACH_TYPE	MACH_TYPE_SECOA62
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(2 * SZ_1M)
+
+#define CONFIG_BOARD_EARLY_INIT_F
+#define CONFIG_BOARD_LATE_INIT
+
+#define CONFIG_MXC_UART
+#define CONFIG_MXC_UART_BASE		UART2_BASE
+
+
+/* I2C Configs */
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC
+#define CONFIG_SYS_I2C_MXC_I2C2         /* enable I2C bus 2 */
+#define CONFIG_SYS_I2C_MXC_I2C3         /* enable I2C bus 3 */
+#define CONFIG_SYS_I2C_SPEED            100000
+#define CONFIG_I2C_EDID
+
+
+/* Network support */
+
+#define CONFIG_FEC_MXC
+#define CONFIG_MII
+#define IMX_FEC_BASE                    ENET_BASE_ADDR
+#define CONFIG_FEC_XCV_TYPE             RGMII
+#define CONFIG_ETHPRIME                 "FEC"
+#define CONFIG_FEC_MXC_PHYADDR          6
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_MICREL
+#define CONFIG_PHY_MICREL_KSZ9031
+
+
+/* watchdog */
+#define CONFIG_HW_WATCHDOG
+
+#define APX_WDT_TRIGGER_BASE      GPIO3_BASE_ADDR
+#define APX_WDT_TRIGGER_NUM       25
+
+#define APX_WDT_ENABLE_BASE       GPIO4_BASE_ADDR
+#define APX_WDT_ENABLE_NUM        11
+
+
+/* Command definition */
+#define CONFIG_CMD_BMODE
+
+#define CONFIG_SYS_MEMTEST_START	0x10000000
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START + 500 * SZ_1M)
+
+/* MMC Configuration */
+#define CONFIG_SYS_FSL_USDHC_NUM 2
+#define CONFIG_MMCROOT	"/dev/mmcblk0p2"
+#define CONFIG_SYS_FSL_ESDHC_ADDR	0
+
+#define CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+
+#define UBOOT_DEVICE	"mmc"
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"script=uEnv.txt\0" \
+	"image=/boot/zImage\0" \
+	"console=ttymxc1\0" \
+	"splashpos=m,m\0" \
+	"fdt_high=0xffffffff\0" \
+	"initrd_high=0xffffffff\0" \
+	"fdt_file=autodetect\0" \
+	"fdt_addr=0x18000000\0" \
+	"boot_fdt=try\0" \
+	"ip_dyn=yes\0" \
+	"mmcdev=0\0" \
+	"mmcpart=1\0" \
+	"mmcrootfstype=ext4\0" \
+	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
+	"mmcargs=setenv bootargs console=${console},${baudrate} ${video} ${memory} " \
+		"root=${mmcroot} rootfstype=${mmcrootfstype} ahci_imx.hotplug=1\0" \
+	"loadbootscript=" \
+		"ext2load " UBOOT_DEVICE " ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
+	"bootscript=echo Running bootscript from mmc ...; " \
+		"env import -t ${loadaddr} ${filesize};\0" \
+	"loadimage=ext2load " UBOOT_DEVICE " ${mmcdev}:${mmcpart} ${loadaddr} ${image}\0" \
+	"loadfdt=ext2load " UBOOT_DEVICE " ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"run mmcargs; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if run loadfdt; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0" \
+	"netargs=setenv bootargs console=${console},${baudrate} " \
+		"root=/dev/nfs " \
+	"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp\0" \
+		"netboot=echo Booting from net ...; " \
+		"run netargs; " \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"${get_cmd} ${image}; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if ${get_cmd} ${fdt_addr} ${fdt_file}; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0"
+
+#define CONFIG_BOOTCOMMAND \
+		"mmc dev ${mmcdev}; " \
+		"if mmc rescan; then " \
+			"if run loadbootscript; then " \
+				"run bootscript; " \
+			"fi; " \
+			"udooinit; " \
+			"if run loadimage; then " \
+				"run mmcboot; " \
+			"else run netboot; " \
+			"fi; " \
+		"else run netboot; fi"
+
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
+
+/* Physical Memory Map */
+#define CONFIG_NR_DRAM_BANKS		1
+#define PHYS_SDRAM			MMDC0_ARB_BASE_ADDR
+
+#define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM
+#define CONFIG_SYS_INIT_RAM_ADDR	IRAM_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_SIZE	IRAM_SIZE
+
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+/* Environment organization */
+#define CONFIG_ENV_SIZE			(8 * 1024)
+
+#define CONFIG_ENV_IS_IN_MMC
+#define CONFIG_ENV_OFFSET		(6 * 64 * 1024)
+#define CONFIG_SYS_MMC_ENV_DEV		0
+
+/* SPI */
+#define CONFIG_SPI_FLASH_SPANSION
+#define CONFIG_SPI_FLASH_SST
+#define CONFIG_SPI_FLASH_MTD
+#define CONFIG_SPI_FLASH_BAR
+#define CONFIG_MXC_SPI
+#define CONFIG_CMD_SF
+#define CONFIG_SF_DEFAULT_BUS         0
+#define CONFIG_SF_DEFAULT_CS          (0|(IMX_GPIO_NR(2, 30)<<8))
+#define CONFIG_SF_DEFAULT_SPEED       30000000
+#define CONFIG_SF_DEFAULT_MODE        (SPI_MODE_0)
+
+
+
+/* USB Configs */
+#define CONFIG_CMD_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_MX6
+#define CONFIG_USB_STORAGE
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_MXC_USB_PORTSC                   (PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS                    0
+#define CONFIG_USB_MAX_CONTROLLER_COUNT         2       /* Enabled USB controller number */
+
+
+
+#endif			       /* __CONFIG_H * */
-- 
2.7.4

